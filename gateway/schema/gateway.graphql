input AccessTokenVerificationOptionsInput {
  userId: ID
  audience: String
  roles: [String!]
}

type ActionText {
  value: String!
  action: String
  testID: String
  style: Object
}

"""A full address, including name and phone number"""
type Address {
  """Person's first name"""
  firstName: String!

  """Person's last name"""
  lastName: String!

  """First part or primary line of address"""
  addressOne: String!

  """Second part or secondary line of address"""
  addressTwo: String

  """City name"""
  city: String!

  """Abbreviated 2 letter state name"""
  state: String!

  """Zip code of address"""
  postalCode: String!

  """The country"""
  country: String

  """Phone Number"""
  phoneNumber: String!
}

type AddressDetails {
  """A Honey address (without firstName and lastName)"""
  address: AddressOnly!

  """A uuid4 to uniquely identify this set of requests"""
  sessionToken: ID!
}

"""A full address, including name and phone number"""
input AddressInput {
  """Person's first name"""
  firstName: String!

  """Person's last name"""
  lastName: String!

  """First part or primary line of address"""
  addressOne: String!

  """Second part or secondary line of address"""
  addressTwo: String

  """City name"""
  city: String!

  """Abbreviated 2 letter state name"""
  state: String!

  """Zip code of address"""
  postalCode: String!

  """Phone Number"""
  phoneNumber: String!
}

"""
An address without name or phone number.
Sending extraneous fields using the 'Address' object needs unnecessary handling in internal-api-cart
"""
type AddressOnly {
  """First part or primary line of address"""
  addressOne: String!

  """Second part or secondary line of address"""
  addressTwo: String

  """City name"""
  city: String!

  """Abbreviated 2 letter state name"""
  state: String!

  """Zip code of address"""
  postalCode: String!
}

"""An address without name or phone number."""
input AddressOnlyInput {
  """First part or primary line of address"""
  addressOne: String!

  """Second part or secondary line of address"""
  addressTwo: String

  """City name"""
  city: String!

  """Abbreviated 2 letter state name"""
  state: String!

  """Zip code of address"""
  postalCode: String!
}

"""
A single stripped down 'Google address' prediction object with relevant IDs
"""
type AddressPrediction {
  """`addressOne` + `addressTwo` of a Honey address returned by Google"""
  address: String!

  """
  A Google Places API textual identifier that uniquely identifies a place
  """
  placeId: ID!
}

type AddressPredictions {
  """An array of Prediction objects, usually  5 in total"""
  addressPredictions: [AddressPrediction!]!

  """A uuid4 to uniquely identify this set of requests"""
  sessionToken: ID!
}

input AddressUpdateInput {
  """Person's first name"""
  firstName: String

  """Person's last name"""
  lastName: String

  """First part or primary line of address"""
  addressOne: String

  """Second part or secondary line of address"""
  addressTwo: String

  """City name"""
  city: String

  """Abbreviated 2 letter state name"""
  state: String

  """Zip code of address"""
  postalCode: String

  """Phone Number"""
  phoneNumber: String
}

"""Address verification results"""
type AddressVerification {
  """Whether the input was an exact match"""
  isExactMatch: Boolean!

  """Whether the input is considered deliverable"""
  isDeliverable: Boolean!

  """Message from 3rd party API"""
  message: String

  """Suggested address for the client to display to the user"""
  suggestedAddress: AddressOnly

  """Deliverability assessment from 3rd party API"""
  deliverability: String

  """Deliverability analysis from 3rd party API """
  deliverabilityAnalysis: JSON
}

input AddSenderDomainInput {
  """Store ID"""
  storeId: String!

  """Email domain"""
  domain: String!

  """Whether domain is currently active"""
  isActive: Boolean!
}

input AddStoreSupportInput {
  affId: String
  affNetwork: String!
  affNetworkOther: String
  fmtcId: String
  promoUrls: [AddStoreSupportInputPromoUrls!]
  storeCountry: String!
  storeEmail: String
  storeName: String!
  storeUrl: String!
}

input AddStoreSupportInputPromoUrls {
  promoUrl: String!
}

"""cashback stats"""
type AffiliateCashbackStatsResponse {
  storeId: ID
  numTransactions: String!
  periodStart: Timestamp!
  periodEnd: Timestamp!
  totalCommissionValue: String!
  totalGoldCommissionValue: String!
  totalGoldGivenValue: String!
  totalSaleValue: String!
}

type AffiliateEntry {
  val: Int!
  url: String!
  providers: [ProviderIdType!]!
}

enum AffiliateProviderIdType {
  AF
  AFN
  AL
  APD
  AW
  CF
  CJ
  DK
  EBAY
  FLIPKART
  GR
  HOTELSTORM
  IA
  IB
  IR
  LC
  LS
  LSJ
  LT
  OL
  OM
  OND
  PHG
  PJ
  SAS
  SD
  SHIMPLY
  SNAPDEAL
  SZ
  TD
  TT
  VCOMM
  VORCU
  WG
  WX
  ZX
}

type AffiliateTagInfo {
  extension_links: [AffiliateEntry!]
  hbc: [AffiliateEntry!]
  offer_claim: [AffiliateEntry!]
  website: [AffiliateEntry!]
}

enum AggregationType {
  BRANDS
  CATEGORIES
  STORES
  TAGS
}

"""
AltOrderNumber contains information about an alternate order number for an order
"""
type AltOrderNumber {
  orderId: ID!
  orderNumber: String!
}

"""
AltOrderNumbersQuery describes acceptable query input for getAltOrderNumbers
"""
input AltOrderNumbersQuery {
  orderId: ID
  orderNumber: String
}

type AmbassadorApplicationEvent {
  user: User!
  userId: ID!
  created: Timestamp!
  state: AmbassadorApplicationState!
}

input AmbassadorApplicationInput {
  accountList: [AmbassadorApplicationInputAccountList!]
  emailAddress: String!
  firstName: String!
  lastName: String!
  middleName: String
  phoneNumber: String
}

input AmbassadorApplicationInputAccountList {
  descriptionSM: String
  followerCountSM: String!
  platformSM: String!
  usernameSM: String!
}

enum AmbassadorApplicationState {
  APPROVED
  DECLINED
  PENDING
  REVOKED
}

input AmbassadorDecisionInput {
  decisionType: String!
  emailAddress: String!
  referralToken: String!
  userId: String
  visitorId: String
}

type AnalyzedFilters {
  """list of colors identified from search query"""
  colors: [String!]!

  """list of honey standardized colors from search query"""
  honeyColors: [String!]!

  """list of sizes identified from search query"""
  sizes: [String!]!
}

"""Analyzed query results"""
type AnalyzedQuery {
  """list of brands identified from search query"""
  brands: [String!]!

  """list of category predictions from search query"""
  categories: [Prediction!]!

  """list of collections identified from search query"""
  collections: [String!]!

  """honey standardized filters"""
  filters: AnalyzedFilters!

  """parsed query string"""
  normalizedQuery: String!

  """original query string"""
  query: String!

  """suggested query with corrected spelling"""
  spellCorrectedQuery: String

  """list of stopwords identified from search query"""
  stopWords: [String!]!

  """list of stores identified from search query"""
  stores: [String!]!
}

"""
A log that contains the information of a transaction update that made by a Honey
employee from internal dashboard or the anomalous transaction detector.
Persisted in anomalousTransactionLogs table.
Multiple AnomalousTransactionLog items can be related to 1 transaction.
"""
type AnomalousTransactionLog {
  """Transaction ID"""
  transactionId: ID!

  """Original state of transaction when the log was created"""
  state: String!

  """
  Email identifier of the user (Honey employee) or system that created this log
  """
  operatorEmail: String!

  """Type of the operation"""
  operationType: String!

  """Risk factor of the anomalous transaction finding"""
  riskFactor: String!

  """Field updated in the related transaction"""
  fieldUpdated: String!

  """The new value of the updated field"""
  fieldValue: String!

  """User ID (Honey user)"""
  userId: String!

  """Type of the transaction"""
  type: String!

  """Timestamp of the related transaction creation"""
  transactionCreated: Timestamp!

  """Datetime of the object creation"""
  created: DateTime!
}

"""
Input type for creating a AnomalousTransactionLog.
See AnomalousTransactionLog for the speicific fields.
"""
input AnomalousTransactionLogInput {
  transactionId: ID!
  state: String!
  operatorEmail: String!
  operationType: String!
  riskFactor: String!
  fieldUpdated: String!
  fieldValue: String!
}

input AppDifferentiatorInput {
  mobileInstallId: String
  subject: String
  userEmail: String!
  userId: String
}

type AuthenticatedUser {
  user: User!
  refreshToken: String!
  accessToken: String!
}

type AuthPublicKeys {
  refreshToken: Object!
  accessToken: Object!
}

"""Fields needed to award available gold for an offer"""
input AwardAvailableOfferGoldInput {
  """ID of the offer transaction to lock"""
  offerTransactionId: String!

  """Whether the offer transaction should be locked with 0 value"""
  shouldLockAtZero: Boolean!

  """Type of offer transaction to lock"""
  offerTransactionType: OfferTransactionType!
}

"""Return type for awarding Offers gold"""
type AwardOfferGoldResponse {
  success: Boolean!

  """Contain any errors that occurred while awarding the offer"""
  error: Object
}

"""Fields needed to award pending gold for an offer"""
input AwardPendingOfferGoldInput {
  """ID of the transaction that triggered this award"""
  linkedTransactionId: String

  """When the pending gold is expected to lock, in Unix ms"""
  lockedTime: Timestamp!

  """ID of the offer to be awarded"""
  offerId: String!

  """ID of the order that triggered this award"""
  offerOrderId: String

  """Type of offer transaction to create"""
  offerTransactionType: OfferTransactionType!

  """ID of the user receiving the award"""
  userId: String!
}

"""A collection of fields from stores.stores needed to identify a store."""
type BasicStoreInfo implements Node {
  """The ID of an object"""
  id: ID!

  """The store id of the store"""
  storeId: ID!

  """The name of the store"""
  name: String!

  """The label of the store"""
  label: String!

  """The country of the store"""
  country: String!

  """The url of the store"""
  url: String!

  """Whether to show this store on shop pages"""
  indexShopPage: Boolean
}

input BatchOrderPackageUpdateInput {
  orderId: ID!
  orderPackageId: ID!
  orderPackage: OrderPackageUpdateInput!
}

type BenefitLander {
  benefitTip: BenefitTip!
  benefitLander: BenefitLanderContent!
  creditCardOffers: [CreditCardOffer]
}

type BenefitLanderContent {
  benefitLanderId: ID!
  landerTitle: String!
  landerDescription: String!
  iconUrl: String
  otherCardBenefits: [OtherCardBenefit]
}

"""Deprecated. Do not use."""
type Benefits {
  title: String @deprecated(reason: "Deprecated. Do not use.")
  benefitDescription: String @deprecated(reason: "Deprecated. Do not use.")
}

type BenefitTip {
  creditCardOfferId: ID!
  primaryTipDescription: String!
  tipTitle: String!
  cardLink: String!
  fineprint: String!
  fineprintUrl: String
  active: Boolean!
  isExperimental: Boolean
  boxOneTitle: String
  boxTwoTitle: String
  boxOneValue: String
  boxTwoValue: String
  cashbackPercentage: Float
  ctaCopy: String
  pointValue: String
  pointsPerDollar: String
  created: String @deprecated(reason: "Deprecated. Do not use.")
  updated: String @deprecated(reason: "Deprecated. Do not use.")
  benefits: Benefits @deprecated(reason: "Deprecated. Do not use.")
  features: Features @deprecated(reason: "Deprecated. Do not use.")
  creditQualification: String @deprecated(reason: "Deprecated. Do not use.")
  cardName: String @deprecated(reason: "Deprecated. Do not use.")
  rating: Float @deprecated(reason: "Deprecated. Do not use.")
  imgUrl: String @deprecated(reason: "Deprecated. Do not use.")
  secondaryTipDescription: String @deprecated(reason: "Deprecated. Do not use.")
}

type BenefitTipsSummary {
  creditCardOffersCount: Int!
  creditCardOfferIds: [String]!
}

"""Integer with a value of 0 or 1"""
scalar Binary

input BookingEmailTriggerInput {
  subject: String
  userEmail: String!
  userId: String!
}

type BrandPreference {
  score: Float!
  brand: String!
}

input BrandPreferenceInput {
  score: Float!
  brand: String!
}

type Button {
  type: ButtonType!
  action: String!
  testID: String!
}

enum ButtonType {
  ACTIVATE_SMART_DROPLIST
  BUY
  FOLLOW
  OFFER
  SHOP
  SYNC_DROPLIST_ITEMS
}

"""TODO: use ID or String to represent spanner card id?"""
interface Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
}

input CardUpdateInput {
  cardId: ID!
  userId: ID!
  weight: Timestamp!
}

input CarrierRegexAddInput {
  carrierName: CarrierTypeEnum!
  flags: String!
  pattern: String!
}

type CarrierRegexes {
  carrierName: CarrierTypeEnum!
  regexes: [WalletEmailRegex!]!
}

enum CarrierTypeEnum {
  DHL
  FEDEX
  ONTRAC
  UPS
  USPS
}

"""Represents a cart as used by the Mobile app"""
type Cart {
  """The ID of the parent CartApiSession"""
  cartApiSessionId: ID!

  """The ID of this cart"""
  cartId: ID!

  """Stores in this cart, with additional data"""
  cartStores: [CartStore]!

  """If checkout wasn't able to submit, this is why"""
  checkoutError: CheckoutError

  """Session data needed for sdata"""
  checkoutSession: CheckoutSession

  """If a payment method had an error, this will represent which one"""
  erroredCreditCardSnapshotId: String
  erroredCreditCardSnapshot: CreditCardSnapshot

  """If a purchase had an error, this will represent which one"""
  erroredPurchaseId: String

  """If a shipping method had an error, this will represent which one"""
  erroredShippingAddressSnapshotId: String
  erroredShippingAddressSnapshot: ShippingAddressSnapshot

  """
  If any orders in this cart had an error, this list will contain which ones
  """
  erroredOrders: [CartOrder]!

  """Timestamp when Find Savings was completed"""
  findSavingsCompletedAt: Timestamp

  """Two Tap returned 'purchaseId' field"""
  findSavingsPurchaseId: String

  """When Find Savings started"""
  findSavingsRanAt: Timestamp

  """If Find Savings is currently in progress"""
  findSavingsInProgress: Boolean

  """When findSavings results were seen"""
  findSavingsSeenAt: Timestamp

  """When findSavings failed for one or more sites"""
  findSavingsFailed: Boolean

  """The associated HoneyOrder"""
  honeyOrder: HoneyOrder

  """Estimates for the given ShippingSpeed"""
  shippingEstimates(speed: ShippingSpeed!): ShippingEstimates

  """The ID of which credit card was selected for this cart"""
  selectedCreditCardId: String

  """Which credit card was selected for this cart"""
  selectedCreditCard: CreditCard

  """The ID of which shipping address was selected for this cart"""
  selectedShippingAddressId: String

  """Which shipping address was selected for this cart"""
  selectedShippingAddress: ShippingAddress

  """The associated TwoTap Cart ID"""
  twoTapCartId: String

  """The associated TwoTap Purchase ID"""
  twoTapPurchaseId: String @deprecated(reason: "Use HoneyOrder.twoTapPurchaseId instead")

  """A message from TwoTap regarding this purchase"""
  twoTapPurchaseMessage: String

  """If the cart is waiting for updates from Two Tap, this will be false"""
  twoTapSynced: Boolean

  """Whether this cart is the user's active cart"""
  isActiveCart: Boolean!

  """If a checkout is currently processing for this cart"""
  checkoutInProgress: Boolean

  """The timestamp of when checkout was started"""
  checkoutStartedAt: Timestamp
}

"""Corresponds to either a user or a device id if a user is logged out"""
type CartApiSession {
  cart(query: CartQuery!): Cart

  """Either the provided userId or device Id"""
  cartApiSessionId: ID!
}

input CartApiSessionQueryInput {
  """
  The user's userId, use this if coming from the frontend. Make sure to allow
  gateway to populate userId in the operation varaibles
  """
  userId: ID

  """
  For a logged out user, provide the device ID and a ppend the string "loggedOut"
  for example, if the device ID is 12345 you should send 12345loggedOut
  """
  deviceId: ID

  """
  Internal use only, do not expose to external clients. Can be either a deviceId or a userId
  """
  cartApiSessionId: ID
}

"""A CartItem is a wrapper around a product in a user's cart"""
type CartItem {
  """Primary key field; the ID of the cartApiSession for this cartItem"""
  cartApiSessionId: ID!

  """Primary key field; the ID of the cart for this cartItem"""
  cartId: ID!

  """Primary key field; The ID of the store for this cartItem"""
  storeId: ID!

  """Primary key field; The ID of the product for this cartItem"""
  productId: ID!

  """The raw product"""
  product: Product

  """Quantity of this product in the user's cart"""
  quantity: Int

  """The TwoTap status for this item"""
  twoTapStatus: String

  """The TwoTap status_reason for this item"""
  twoTapStatusReason: String

  """Price Snapshot for this item in the users cart"""
  priceSnapshot: Int
}

"""Update a cart item"""
input CartItemUpdateInput {
  """The TwoTap status for this item"""
  twoTapStatus: String

  """The TwoTap status_reason for this item"""
  twoTapStatusReason: String

  """Price Snapshot for this item in the users cart"""
  priceSnapshot: Int
}

"""CartOrder contains information about an order placed at a store"""
type CartOrder {
  """ID of this CartOrder"""
  id: ID!

  """ID of the honey order"""
  honeyOrderId: String!

  """ID of the store"""
  storeId: String

  """Store associated with this CartOrder"""
  store: Store

  """Name of the store"""
  storeName: String @deprecated(reason: "Use store.name")

  """ID of this transaction"""
  transactionId: ID

  """ID of the user who placed the order"""
  userId: ID!

  """If we have received an Email for this order"""
  isEmailVerified: Boolean

  """Timestamp of when the order was placed"""
  orderedAt: Timestamp

  """Order number provided by store after checkout"""
  orderNumber: String

  """Email used to place the order"""
  emailUsed: String

  """Products ordered"""
  products: [CartOrderProduct]!

  """Savings amount"""
  savings: Int

  """Shipping amount"""
  shipping: Int

  """Subtotal amount"""
  subTotal: Int

  """Tax amount"""
  tax: Int

  """Total amount"""
  total: Int

  """Savings amount estimated at a time of checkout"""
  checkoutSnapshotSavings: Int

  """Shipping amount estimated at a time of checkout"""
  checkoutSnapshotShipping: Int

  """Subtotal amount estimated at a time of checkout"""
  checkoutSnapshotSubTotal: Int

  """Tax amount estimated at a time of checkout"""
  checkoutSnapshotTax: Int

  """Total estimated amount at a time of checkout"""
  checkoutSnapshotTotal: Int

  """Savings amount to show to user"""
  displaySavings: Int

  """Shipping amount to show to user"""
  displayShipping: Int

  """Subtotal amount to show to user"""
  displaySubTotal: Int

  """Tax amount to show to user"""
  displayTax: Int

  """Total amount to show to user"""
  displayTotal: Int

  """Amount refunded"""
  refundValue: Int

  """Backwards-compatible version of status field"""
  status: String

  """Order status (e.g. "processing", "shipped", "error")"""
  statusV2: String

  """Packages associated with this order as a raw Object"""
  packages: [Object] @deprecated(reason: "Use CartOrder.orderPackages instead")

  """ID of the creditCardSnapshot used for this order"""
  creditCardSnapshotId: String

  """The creditCardSnapshot used for this order"""
  creditCardSnapshot: CreditCardSnapshot

  """ID of the shippingAddressSnapshot used for this order"""
  shippingAddressSnapshotId: String

  """The shippingAddressSnapshot used for this order"""
  shippingAddressSnapshot: ShippingAddressSnapshot

  """TwoTap purchaseId"""
  twoTapPurchaseId: String @deprecated(reason: "Use HoneyOrder.twoTapPurchaseId instead")

  """Last 4 digits of CC"""
  partialCreditCardNumber: String @deprecated(reason: "Use creditCardSnapshot instead")

  """CC issuer"""
  creditCardIssuer: String @deprecated(reason: "Use creditCardSnapshot instead")

  """Shipping address"""
  shippingAddress: Address @deprecated(reason: "Use shippingAddressSnapshot instead")

  """Two Tap order error information"""
  twoTapOrderError: TwoTapOrderError

  """Packages associated with this order"""
  orderPackages: [OrderPackage]!

  """Last four digits of virtual credit card"""
  virtualCreditCardLastFour: String
}

"""Fields available for creating a CartOrder"""
input CartOrderAddInput {
  """ID of the honey order"""
  honeyOrderId: String

  """ID of the store"""
  storeId: String!

  """Name of the store"""
  storeName: String

  """ID of this transaction"""
  transactionId: ID

  """Timestamp of when the order was placed"""
  orderedAt: Timestamp

  """Order number provided by store after checkout"""
  orderNumber: String

  """Email used to place the order"""
  emailUsed: String

  """Products ordered"""
  products: [CartOrderProductAddInput]!

  """Savings amount"""
  savings: Int

  """Shipping amount"""
  shipping: Int

  """Subtotal amount"""
  subTotal: Int

  """Tax amount"""
  tax: Int

  """Total amount"""
  total: Int

  """Amount refunded"""
  refundValue: Int

  """Order status (e.g. "processing", "shipped", "error")"""
  status: String

  """
  ID of the snapshot of the credit card used for this order
  Deprecated in favor of partialCreditCardNumber and creditCardIssuer fields.
  """
  creditCardSnapshotId: String

  """
  ID of the snapshot of the shipping address used for this order
  Deprecated in favor of shippingAddress field.
  """
  shippingAddressSnapshotId: String

  """TwoTap purchaseId"""
  twoTapPurchaseId: String

  """Last 4 digits of CC"""
  partialCreditCardNumber: String

  """CC issuer"""
  creditCardIssuer: String

  """Shipping address"""
  shippingAddress: AddressInput
}

"""CartOrderProduct contains information about a product for a CartOrder"""
type CartOrderProduct {
  """ID of this CartOrderProduct"""
  id: ID

  """ID of the CartOrder this belongs to"""
  orderId: ID

  """ID of the honey order"""
  honeyOrderId: String! @deprecated(reason: "Use CartOrder.honeyOrderId instead")

  """ID of the store"""
  storeId: String @deprecated(reason: "Use CartOrder.storeId instead")

  """ID of the user who placed the order"""
  userId: ID! @deprecated(reason: "Use CartOrder.userId instead")

  """Image URL"""
  imageUrl: String!

  """From Product Catalog object"""
  title: String!

  """The number of items the user ordered for this product"""
  quantity: Int!

  """
  The price paid for this product in the lower currency (i.e. cents if paid in US dollars)
  """
  pricePaid: Int

  """
  Estimated price at the time of checkout in the lower currency (i.e. cents if paid in US dollars)
  """
  checkoutSnapshotPrice: Int

  """The currency used to purchase this product"""
  currency: String

  """Product Catalog v3 id"""
  productId: String!
  product: Product

  """Amount of honey gold offered for product at checkout"""
  offerGold: Int

  """ID of the offer"""
  offerId: ID

  """Product details object"""
  productDetails: Object

  """Whether the product is a final sale"""
  finalSale: Boolean
  error: String
}

"""CartOrderProduct contains information about a product for a CartOrder"""
input CartOrderProductAddInput {
  """Image URL"""
  imageUrl: String!

  """From Product Catalog object"""
  title: String!

  """The number of items the user ordered for this product"""
  quantity: Int!

  """The price paid for this product"""
  pricePaid: Int

  """The currency used to purchase this product"""
  currency: String

  """Product Catalog v3 id"""
  productId: String!

  """Amount of honey gold offered for product at checkout"""
  offerGold: Int

  """ID of the offer"""
  offerId: ID

  """Product details object"""
  productDetails: Object

  """Whether the product is a final sale"""
  finalSale: Boolean
}

"""Input for updating a CartOrderProduct"""
input CartOrderProductUpdateInput {
  error: String
  pricePaid: Int
  status: String
}

input CartOrderQueryInput {
  """If we have received an Email for this order"""
  isEmailVerified: Boolean

  """Order number provided by store after checkout"""
  orderNumber: String

  """ID of the store"""
  storeId: String

  """ID of this transaction"""
  transactionId: ID

  """Order status (e.g. "processing", "shipped", "error")"""
  status: String

  """TwoTap purchaseId"""
  twoTapPurchaseId: String

  """Whether the CartOrder's `seenAt` field contains a non-null value"""
  isSeen: Boolean

  """Whether the CartOrder's `dismissedAt` field contains a non-null value"""
  isDismissed: Boolean

  """Pagination: page size"""
  limit: Int

  """Pagination: offset value"""
  start: Int

  """Field to sort by"""
  sortBy: String

  """'asc' or 'desc'"""
  sortOrder: String
}

"""Fields available for querying Unknown Orders"""
input CartOrdersUnknownQueryInput {
  """ID of the store"""
  storeId: String
}

"""Fields available for updating a CartOrder"""
input CartOrderUpdateInput {
  """If we have received an Email for this order"""
  isEmailVerified: Boolean

  """Order number provided by store after checkout"""
  orderNumber: String

  """Order status (e.g. "processing", "shipped", "error")"""
  status: String

  """ID of this transaction"""
  transactionId: ID

  """Fields available to update in the twoTapOrderError object"""
  twoTapOrderError: TwoTapOrderErrorUpdateInput

  """TwoTap purchaseId"""
  twoTapPurchaseId: String

  """Last 4 digits of CC"""
  partialCreditCardNumber: String

  """CC issuer"""
  creditCardIssuer: String

  """Shipping address"""
  shippingAddress: AddressInput

  """Savings amount"""
  savings: Int

  """Shipping amount"""
  shipping: Int

  """Subtotal amount"""
  subTotal: Int

  """Tax amount"""
  tax: Int

  """Total amount"""
  total: Int

  """Amount refunded"""
  refundValue: Int

  """Last four digits of virtual credit card"""
  virtualCreditCardLastFour: String
}

"""Query object for getCart"""
input CartQuery {
  """Selector for Whether the cart is active"""
  active: Boolean

  """Honey Cart ID"""
  cartId: ID
  twoTapCartId: ID

  """
  If true, gets a cart where findSavingCompletedAt is not null and findSavingsSeenAt is null
  """
  findSavingsUnseen: Boolean

  """If true, gets a cart where findSavingsInProgress is true"""
  findSavingsInProgress: Boolean

  """TwoTap Purchase Id associated with running find savings"""
  findSavingsPurchaseId: String
}

type CartSession {
  """Array of CartItems"""
  items: [CartSessionItem]
}

type CartSessionItem {
  """Quantity of item in the cart"""
  quantity: Int

  """
  A Product. Type is Object because mutations on CartSessions don't need to return the full product info.
  """
  product: Object
}

"""
A CartStore represents a single store in a cart (which may have many stores)
"""
type CartStore {
  """Primary key field; the ID of the session for this cartStore"""
  cartApiSessionId: ID!

  """Primary key field; the ID of the cart for this cartStore"""
  cartId: ID!

  """A list of items from this store in the cart"""
  cartItems: [CartItem]!

  """
  The shipping estimates for the given speed for this store. Speed can be
  "fastest", "cheapest", "fs_fastest" or "fs_cheapest".
  """
  shippingEstimates(speed: ShippingSpeed!): CartStoreShippingEstimates

  """The shipping speed that the user selected for this store"""
  selectedShippingOption: ShippingSpeed

  """Primary key field; The ID of the store"""
  storeId: ID!

  """The raw store, in all its glory"""
  store: Store

  """The TwoTap status for this store; only used after running findSavings"""
  twoTapStatus: String

  """
  The TwoTap status_reason for this store; only used after running findSavings
  """
  twoTapStatusReason: String

  """For sdata, Id generated by client when the purchase began"""
  purchaseInitiatedId: String
}

"""CartStoreAccount contains information about"""
type CartStoreAccount {
  """Record identifier"""
  id: ID!

  """The email used to register at the store website"""
  email: String!

  """Store id. A value of "0" means this email is used in multiple stores."""
  storeId: String!

  """User Id"""
  userId: String!

  """Active flag"""
  isActive: Boolean
}

input CartStoreAccountAddInput {
  """The email used to register at the store website"""
  email: String!

  """Store id"""
  storeId: String!
}

input CartStoreAccountQueryInput {
  """The email used to register at the store website"""
  email: String
}

"""Shipping Estimates for a single store"""
type CartStoreShippingEstimates {
  """TwoTap fetch status"""
  status: String

  """TwoTap fetch description"""
  description: String

  """The estimated shipping price for all products from this store"""
  shippingPrice: Int

  """The estimated sales tax for all products from this store"""
  salesTax: Int

  """The estimated find price for all products from this store"""
  finalPrice: Int

  """The estimated subtotal for all products from this store"""
  subtotal: Int

  """The estimated coupon value that will be applied to the order"""
  couponValue: Int
}

input CartStoreShippingEstimatesUpsertInput {
  status: String
  description: String
  shippingPrice: Int
  salesTax: Int
  finalPrice: Int
  subtotal: Int
  couponValue: Int
}

input CartStoreUpdateInput {
  """The shipping speed the user selected"""
  selectedShippingOption: ShippingSpeed

  """The TwoTap status for this store; only used after running findSavings"""
  twoTapStatus: String

  """
  The TwoTap status_reason for this store; only used after running findSavings
  """
  twoTapStatusReason: String
}

"""Input for updating a cart"""
input CartUpdateInput {
  """Session data needed for sdata"""
  checkoutSession: CheckoutSessionUpdateInput

  """The ID of the credit card that had an error if any"""
  erroredCreditCardId: String

  """The ID of the shipping address that had an error if any"""
  erroredShippingAddressId: String

  """The ID of the credit card that was selected for this cart"""
  selectedCreditCardId: String

  """The ID of the shipping address that was selected for this cart"""
  selectedShippingAddressId: String

  """The shipping estimate for the cheapest shipping"""
  shippingEstimatesCheapest: ShippingEstimatesInput

  """The shipping estimate for the fastest shipping"""
  shippingEstimatesFastest: ShippingEstimatesInput

  """The associated TwoTap cart ID"""
  twoTapCartId: String

  """Whether this cart has been synced with TwoTap"""
  twoTapSynced: Boolean

  """Whether this cart should be the user's active cart"""
  isActiveCart: Boolean

  """Timestamp when Find Savings was completed"""
  findSavingsCompletedAt: Timestamp

  """Two Tap returned 'purchaseId' field"""
  findSavingsPurchaseId: String

  """If Find Savings is currently in progress"""
  findSavingsInProgress: Boolean

  """Ts of when a user saw their fs results"""
  findSavingsSeenAt: Timestamp

  """When findSavings failed for one or more sites"""
  findSavingsFailed: Boolean
}

type CashbackSettingsResponse {
  distributionGamma: Float!
  goldCommissionGivenPercentTarget: Float!
  offerMaxPercentCap: Int!
  offerMaxPercentMultiplier: Float!
  offerMinTransactions: Int!
}

input CashbackSettingsUpdate {
  distributionGamma: Float
  goldCommissionGivenPercentTarget: Float
  offerMaxPercentCap: Int
  offerMaxPercentMultiplier: Float
  offerMinTransactions: Int
}

input CashbackStatsCreate {
  numTransactions: String!
  periodStart: Timestamp!
  periodEnd: Timestamp!
  totalCommissionValue: String!
  totalGoldCommissionValue: String!
  totalGoldGivenValue: String!
  totalSaleValue: String!
}

type CashbackStatsResponse implements Node {
  """The ID of an object"""
  id: ID!
  storeId: ID!
  numTransactions: String!
  periodStart: Timestamp!
  periodEnd: Timestamp!
  totalCommissionValue: String!
  totalGoldCommissionValue: String!
  totalGoldGivenValue: String!
  totalSaleValue: String!
  updated: Timestamp!
}

type Category {
  categoryId: ID!
  isLeaf: Boolean!
  categoryValue: String!
  imageUrl: String
}

type CategoryPreference {
  score: Float!
  category: String!
}

input CategoryPreferenceInput {
  score: Float!
  category: String!
}

enum CategoryTypeEnum {
  CARRIER
  EMAIL_CLASSIFY_TRX
  ORDER_NUMBER
  ORDER_STATUS_CANCELED
  ORDER_STATUS_CONFIRMED
  ORDER_STATUS_DELIVERED
  ORDER_STATUS_SHIPPED
}

input CheckoutAbandonedCartInput {
  errorTitle: String!
  multipleProducts: Boolean
  pendingGold: Int
  stores: [CheckoutAbandonedCartInputStores!]!
  subject: String!
  title: String
  userEmail: String!
  userId: String!
}

input CheckoutAbandonedCartInputStores {
  products: [CheckoutAbandonedCartInputStoresProducts!]!
  storeId: String
  storeName: String!
}

input CheckoutAbandonedCartInputStoresProducts {
  attributes: [String!]
  honeyGold: String
  imageUrl: String!
  title: String!
  totalPrice: String!
  unitPrice: String!
}

input CheckoutCartPriceDropInput {
  multipleProducts: Boolean!
  numExtraItems: String
  products: [CheckoutCartPriceDropInputProducts!]!
  subject: String!
  title: String
  userEmail: String!
  userId: String!
}

input CheckoutCartPriceDropInputProducts {
  currentPrice: String!
  imageUrl: String!
  originalPrice: String!
  shopUrl: String!
  storeName: String!
  title: String!
  variantValues: String!
}

type CheckoutError {
  type: String!
  message: String!
}

input CheckoutFoundSavingsInput {
  deepLink: String!
  emailHash: String!
  errorTitle: String
  goldBonus: Boolean!
  stores: [CheckoutFoundSavingsInputStores!]!
  subject: String
  totalAfterSavings: String!
  totalBeforeSavings: String!
  totalSavings: String!
  userEmail: String
  userId: String!
}

input CheckoutFoundSavingsInputStores {
  goldBonus: String
  name: String!
  storeId: String!
  storeSavings: String
}

"""Input for a checkout operation"""
input CheckoutInput {
  """
  This is legacy and is unsupported by TwoTap`s MOC. A 'fake' or 'dummy' checkout code flow does not exist as of now.
        Legacy description - whether we skip purchase confirmation
  """
  fakeCheckout: Boolean!

  """
  Match the total of the cart items to verify the client is in sync with cart data
  """
  total: Int!

  """Whether to use prices from a previously ran findsavings on this cart"""
  useFindSavingsPrices: Boolean

  """An identifer for the client application (eg iOS app version)"""
  appVersion: String!

  """A unique identifier for the client device (eg IDFA)"""
  deviceId: String

  """
  This is now derived from the requests headers and populated in the
  'serviceInfo' object for "internal-api's". Any input sent is ignored.
        Legacy description - The client operating system, eg Android or iOS.
  """
  mobileOSType: String

  """
  This is now derived from the requests headers and populated in the
  'serviceInfo' object for "internal-api's". Any input sent is ignored.
        Legacy description - IP address of the client
  """
  sourceIp: String

  """UserAgent of the client"""
  userAgent: String

  """The credit card selected for checkout."""
  creditCardId: String!

  """The shipping address selected for checkout."""
  shippingAddressId: String!

  """
  A map of IDs keyed by storeId, use for sdata. If not provided, IDs will be generated.
  """
  purchaseInitiatedIds: [CheckoutPurchaseIdInput!]

  """
  If true, recent potential duplicate orders will not cause an error. Send as true after a user confirms a duplicate order
  """
  allowDuplicateOrders: Boolean
}

input CheckoutOrderCanceledInput {
  errorMessage: String!
  errorTitle: String!
  orderId: String
  orderNumber: String
  originalEmailUrl: String
  products: [CheckoutOrderCanceledInputProducts!]
  storeId: String!
  storeName: String!
  subject: String
  userEmail: String!
  userId: String!
}

input CheckoutOrderCanceledInputProducts {
  attributes: [String!]!
  finalSale: Boolean!
  imageUrl: String!
  productId: String!
  title: String!
}

input CheckoutOrderConfirmedInput {
  billingAddress: CheckoutOrderConfirmedInputBillingAddress!
  creditCard: CheckoutOrderConfirmedInputCreditCard
  honeyEmail: String!
  orderId: String!
  orderNumber: String
  originalEmailUrl: String
  prices: CheckoutOrderConfirmedInputPrices
  products: [CheckoutOrderConfirmedInputProducts!]
  shippingAddress: CheckoutOrderConfirmedInputShippingAddress!
  shippingOption: String!
  storeId: String!
  storeName: String!
  subject: String
  totalHoneyGold: String
  userEmail: String!
  userId: String!
  virtualCreditCardLastFour: String!
}

input CheckoutOrderConfirmedInputBillingAddress {
  name: String!
  state: String!
  street: String!
}

input CheckoutOrderConfirmedInputCreditCard {
  lastFour: String!
  type: String!
}

input CheckoutOrderConfirmedInputPrices {
  savings: String
  shipping: String!
  subtotal: String!
  tax: String!
  total: String!
}

input CheckoutOrderConfirmedInputProducts {
  attributes: [String!]!
  finalSale: Boolean!
  honeyGold: Float
  imageUrl: String!
  productId: String!
  title: String!
}

input CheckoutOrderConfirmedInputShippingAddress {
  name: String!
  state: String!
  street: String!
}

input CheckoutOrderDeliveredInput {
  honeyEmail: String
  orderId: String!
  orderNumber: String
  packages: [CheckoutOrderDeliveredInputPackages!]
  shippingAddress: CheckoutOrderDeliveredInputShippingAddress!
  storeId: String!
  storeName: String!
  title: String!
  userEmail: String!
  userId: String!
}

input CheckoutOrderDeliveredInputPackages {
  carrier: String!
  originalEmailUrl: String
  packageTitle: String!
  shippingMethod: String!
  trackingNumber: String!
  trackingUrl: String!
}

input CheckoutOrderDeliveredInputShippingAddress {
  name: String!
  state: String!
  street: String!
}

input CheckoutOrderPlacedInput {
  billingAddress: CheckoutOrderPlacedInputBillingAddress!
  creditCard: CheckoutOrderPlacedInputCreditCard!
  stores: [CheckoutOrderPlacedInputStores!]!
  userEmail: String!
  userId: String!
}

input CheckoutOrderPlacedInputBillingAddress {
  name: String!
  state: String!
  street: String!
}

input CheckoutOrderPlacedInputCreditCard {
  lastFour: String!
  type: String!
}

input CheckoutOrderPlacedInputStores {
  orderId: String!
  orderNumber: String
  products: [CheckoutOrderPlacedInputStoresProducts!]
  shippingAddress: CheckoutOrderPlacedInputStoresShippingAddress!
  shippingOption: String!
  storeId: String!
  storeName: String!
}

input CheckoutOrderPlacedInputStoresProducts {
  attributes: [String!]!
  finalSale: Boolean!
  honeyGold: Float
  imageUrl: String!
  productId: String!
  title: String!
}

input CheckoutOrderPlacedInputStoresShippingAddress {
  name: String!
  state: String!
  street: String!
}

input CheckoutOrderRefundInput {
  creditCard: CheckoutOrderRefundInputCreditCard
  honeyEmail: String
  moreThanOneItem: Boolean
  orderId: String
  orderNumber: String
  products: [CheckoutOrderRefundInputProducts!]
  refundValue: String!
  storeId: String!
  storeName: String!
  subject: String
  userEmail: String!
  userId: String!
}

input CheckoutOrderRefundInputCreditCard {
  lastFour: String!
  type: String!
}

input CheckoutOrderRefundInputProducts {
  attributes: [String!]!
  finalSale: Boolean!
  honeyGold: Float
  imageUrl: String!
  productId: String!
  title: String!
}

input CheckoutOrderShippedInput {
  honeyEmail: String
  orderId: String!
  orderNumber: String
  packages: [CheckoutOrderShippedInputPackages!]
  shippingAddress: CheckoutOrderShippedInputShippingAddress!
  storeId: String!
  storeName: String!
  userEmail: String!
  userId: String!
}

input CheckoutOrderShippedInputPackages {
  carrier: String!
  originalEmailUrl: String
  packageTitle: String!
  shippingMethod: String!
  trackingNumber: String!
  trackingUrl: String!
}

input CheckoutOrderShippedInputShippingAddress {
  name: String!
  state: String!
  street: String!
}

"""Mapping of storeId to purchaseInitiatedId"""
input CheckoutPurchaseIdInput {
  storeId: ID!
  purchaseInitiatedId: String!
}

"""Response from a checkout operation"""
type CheckoutResponse {
  """The updated cart that checkout was called with"""
  cart: Cart

  """Any errors returned when initiating checkout"""
  errors: [CheckoutError!]
}

"""Session data used for sdata"""
type CheckoutSession {
  """Honey Checkout ID"""
  checkoutSessionId: ID

  """Whether this purchase was affiliate tagged"""
  affiliateTagged: Boolean

  """The ID for this purchase (one per store)"""
  purchaseInitiatedId: String @deprecated(reason: "Use CartStore.purchaseInitiatedId instead")

  """
  The timestamp of when this purchase was initiated (shared for all stores)
  """
  purchaseInitiatedAt: Timestamp

  """The price that was displayed to the user when they began checkout"""
  cartStartPrice: Int
}

"""Input for Session data used for sdata"""
input CheckoutSessionUpdateInput {
  """Honey Checkout ID"""
  checkoutSessionId: ID

  """Whether this purchase was affiliate tagged"""
  affiliateTagged: Boolean

  """The ID for this purchase (one per store)"""
  purchaseInitiatedIds: Object

  """
  The timestamp of when this purchase was initiated (shared for all stores)
  """
  purchaseInitiatedAt: Timestamp

  """The price that was displayed to the user when they began checkout"""
  cartStartPrice: Int
}

enum CheckoutStateType {
  COMING_SOON
  COUPON_ONLY
  HEALTHY
  UNAVAILABLE
  UNSUPPORTED
}

"""CheckoutSupport contains info about whether a store support is enabled"""
type CheckoutSupport implements Node {
  """The ID of an object"""
  id: ID!

  """Store ID"""
  storeId: String!

  """Whether checkout is supported"""
  isCheckoutSupported: Boolean!

  """Whether checkout is currently enabled"""
  isCheckoutHealthy: Boolean

  """When checkout was disabled, or null if enabled"""
  checkoutDisabledAt: Timestamp
}

input CheckoutSupportQueryParams {
  """Whether checkout is supported"""
  isCheckoutSupported: Boolean

  """Whether checkout is currently enabled"""
  isCheckoutHealthy: Boolean
}

input CheckoutSupportUpdateInput {
  """Store ID"""
  storeId: String!

  """Whether checkout is currently enabled"""
  isCheckoutHealthy: Boolean

  """Whether checkout is supported"""
  isCheckoutSupported: Boolean
}

"""
A collection is created for CollectionRecipe.
If CollectionRecipe mimics a class then Collection is an Instance.
"""
type Collection {
  collectionId: ID!
  collectionRecipeId: ID!
  collectionRecipe: CollectionRecipe!
  createdAt: Timestamp!
  expiredAt: Timestamp
  refreshAt: Timestamp
  platform: CollectionPlatform
  productIds: [ID!]
  products(limit: Int): [Product!]
  relatedCollectionIds: [String!]
  relatedCollections(limit: Int): [Collection!]
  title: String!
  authorId: String
  template: String
  shortTitle: String
  imageUrl: String
  heroImageUrl: String
  productSearchParams: String
  collectionPreferences: [CollectionPreference!] @deprecated(reason: "Use collectionPreferencesV2.")
  collectionPreferencesV2: [CollectionPreferenceV2!]
  updatedAt: Timestamp

  """A markdown string to render tips in Collection page."""
  tips: String

  """A markdown string to render editorial content in Collection page."""
  editorialContent: String

  """True value would set meta tag for Google Search Engine"""
  indexCollection: Boolean
}

input CollectionCreateInput {
  expiredAt: Timestamp
  refreshAt: Timestamp
  title: String!
  imageUrl: String
  heroImageUrl: String
  productSearchParams: String!
}

"""
The input parameters for creating a collection in it's datastore (spanner)
"""
input CollectionCreateInputV2 {
  collectionRecipeId: ID!
  desktopActive: Boolean
  desktopExpiredAt: Timestamp!
  desktopProductIds: [ID!]
  desktopRefreshAt: Timestamp!
  imageUrl: String
  heroImageUrl: String
  mobileActive: Boolean
  mobileExpiredAt: Timestamp!
  mobileProductIds: [ID!]
  mobileRefreshAt: Timestamp!
  productSearchParams: String
  shortTitle: String
  title: String!
  authorId: String
  template: String
}

"""
Collections are specific to platform.
These are all the platforms we support.
"""
enum CollectionPlatform {
  DESKTOP
  MOBILE
}

type CollectionPreference {
  collectionId: ID!
  collectionRecipeId: ID!
  preferenceId: ID!
  preferenceScore: Int
  preferenceType: String!
  preferenceValue: String!
  boostScore: Float
}

input CollectionPreferenceCreateInput {
  preferenceScore: Int
  preferenceType: String!
  preferenceValue: String!
  boostScore: Float
}

input CollectionPreferenceUpdateInput {
  collectionId: ID!
  collectionRecipeId: ID!
  preferenceType: String!
  preferenceValue: String!
  preferenceScore: Int
}

"""
The input parameters for creating or inserting a collection preference.
Example of preference:
{
  collectionId: 'c1',
  preferenceType: 'category',
  preferenceValue: 'clothing',
  preferenceScore: 10, // How relatable the collection is to this preference
  boostScore: 2, // Give extra boost to preferenceScore based on past performance.
}
"""
input CollectionPreferenceUpdateInputV2 {
  collectionId: ID!
  preferenceType: String!
  preferenceValue: String!
  preferenceScore: Int
  boostScore: Float
}

type CollectionPreferenceUpdates {
  create: [CollectionPreference!]!
  update: [CollectionPreference!]!
}

"""
Every time we update a collection preference then we try to find an existing match.
If the match exists then we update the preference or else we create a preference.
The matching process only checks collectionId, preferenceType, preferenceValue
"""
type CollectionPreferenceUpdatesV2 {
  create: [CollectionPreferenceV2!]!
  update: [CollectionPreferenceV2!]!
}

"""
Every Collection will be associated with set of preferences to identify itself.
If we created a collection 'Shoes under $100 from Target' then it's preferences could be:
[
  {
    collectionId: 'c1',
    preferenceId: 'p1',
    preferenceScore: 10,
    preferenceType: 'category',
    preferenceValue: 'shoes',
    boostScore: null,
  },
  {
    collectionId: 'c1',
    preferenceId: 'p2',
    preferenceScore: 25,
    preferenceType: 'store',
    preferenceValue: 'Target',
    boostScore: 2.1,
  }
]
"""
type CollectionPreferenceV2 {
  collectionId: ID!
  preferenceId: ID!
  preferenceScore: Int
  preferenceType: String!
  preferenceValue: String!
  boostScore: Float
}

type CollectionPreview {
  collectionId: ID!
  collectionRecipe: CollectionRecipe!
  expiredAt: Timestamp
  platform: CollectionPlatform
  products(limit: Int): [Product!]
  title: String!
  imageUrl: String
  heroImageUrl: String
}

"""
A collection recipe holds the template (or recipe) to create a collection.
Example: A recipe could be created for Shoes under $X in a store
Now, we can create Collections like this:
1. Shoes under $50 in Walmart
2. Shoes under %100 in Target, etc.
"""
type CollectionRecipe implements Node {
  """The ID of an object"""
  id: ID!
  active: Boolean!
  collectionRecipeId: ID!
  authorId: ID
  author: User
  creatorId: ID
  creator: User
  createdAt: Timestamp!
  heroImageUrl: String
  expiredAt: Timestamp
  title: String!
  description: String
  imageUrl: String @deprecated(reason: "Use Collection.imageUrl")
  productSearchRecipe: String!
  boostValue: Float
  refreshInterval: Int
  updatedAt: Timestamp
  qualifier: String
}

input CollectionRecipeCreateInput {
  active: Boolean!
  expiredAt: Timestamp
  creatorId: ID!
  authorId: ID
  boostValue: Float
  productSearchRecipe: String!
  refreshInterval: Int
  description: String
  title: String!
  qualifier: String!
}

input CollectionRecipeUpdateInput {
  active: Boolean
  expiredAt: Timestamp
  creatorId: ID
  authorId: ID
  boostValue: Float
  productSearchRecipe: String
  refreshInterval: Int
  description: String
  title: String
  qualifier: String
}

input CollectionUpdateInput {
  expiredAt: Timestamp
  refreshAt: Timestamp
  title: String
  imageUrl: String
  heroImageUrl: String
  productSearchParams: String
}

"""
The input parameters for updating a collection in it's datastore (spanner)
"""
input CollectionUpdateInputV2 {
  collectionRecipeId: ID
  desktopActive: Boolean
  desktopExpiredAt: Timestamp
  desktopProductIds: [ID!]
  desktopRefreshAt: Timestamp
  imageUrl: String
  heroImageUrl: String
  mobileActive: Boolean
  mobileExpiredAt: Timestamp
  mobileProductIds: [ID!]
  mobileRefreshAt: Timestamp
  productSearchParams: String
  shortTitle: String
  title: String
  tips: String
  editorialContent: String
  authorId: String
  template: String
}

"""
Collections persisted in Spanner have different structure than Collections which are being displayed in client
Once a Collections is Inserted or Updated then these columns are exposed to the Client.
The only client here is internal dash for Explore.
"""
type CollectionUpsertOutput {
  collectionId: ID!
  collectionRecipeId: ID!
  createdAt: Timestamp!
  desktopActive: Boolean
  desktopExpiredAt: Timestamp
  desktopProductIds: [ID!]
  desktopRefreshAt: Timestamp
  imageUrl: String
  heroImageUrl: String
  mobileActive: Boolean
  mobileExpiredAt: Timestamp
  mobileProductIds: [ID!]
  mobileRefreshAt: Timestamp
  productSearchParams: String
  shortTitle: String
  title: String!
  updatedAt: Timestamp

  """A markdown string to render tips in Collection page."""
  tips: String

  """A markdown string to render editorial content in Collection page."""
  editorialContent: String
  authorId: String
  template: String
}

input CommissionRateCreate {
  numTransactions: String!
  commissionRate: Float!
}

type CommissionRateResponse {
  storeId: ID!
  intervalDays: Int!
  numTransactions: String!
  commissionRate: Float!
  updated: Timestamp!
}

type Content {
  type: ContentType!
  value: String
  style: Object
  action: String
  testID: String
}

enum ContentType {
  BREAK
  COUNTDOWN
  GOLDTAG
  ICON
  PRICE
  REFERRAL_COPY_LINK
  TEXT
  TIMESTAMP
}

"""
A representation of a CreditCard for the users wallet. Updates cause the reference to creditCardSnapshot to change.
"""
type CreditCard implements Node {
  """The ID of an object"""
  id: ID!

  """Primary key field; the users  userId"""
  userId: ID!

  """Honey-generated identifier for this Credit Card"""
  creditCardId: ID!

  """Whether this is the user's default credit card"""
  isDefault: Boolean!

  """The snapshot that this CreditCard references"""
  creditCardSnapshot: CreditCardSnapshot!
}

"""
A PCI-safe representation of a Credit Card. Is it not much more than a pointer to Spreedly data.
"""
input CreditCardAddInput {
  """The associated spreedly token for this credit card information"""
  spreedlyToken: String!

  """Deprecated. This data will be fetched from the server."""
  firstSixDigits: String

  """Deprecated. This data will be fetched from the server."""
  lastFourDigits: String

  """Whether the creditCard should the be default creditCard for this user"""
  isDefault: Boolean
}

type CreditCardOffer {
  creditCardOfferId: ID!
  creditCardName: String!
  creditCardDescription: String!
  isAffiliateTracked: Boolean

  """name of the credit card issuer. ex: American Express National Bank"""
  issuerName: String
  marketingBullets: [String]
  introApr: String
  regularApr: String
  annualFee: String
  creditScoreMin: Int
  creditScoreMax: Int
  cardImageUrl: String
  cardApplicationUrl: String
  ratesUrl: String
}

type CreditCardOfferUserAction {
  creditCardOfferUserActionId: ID
  userId: ID
  creditCardOfferId: ID
  action: CreditCardOfferUserActionType
  created: String
}

enum CreditCardOfferUserActionType {
  APPLY
  APPROVED
  BACK
  CLOSE_MODAL
  LEARN_MORE
  PENDING_APPROVAL
  SHOWN
}

"""
A PCI-safe representation of a Credit Card. Is it not much more than a pointer to Spreedly data. Immutable.
"""
type CreditCardSnapshot implements Node {
  """The ID of an object"""
  id: ID!

  """Primary key field; the users  userId"""
  userId: ID!

  """Primary key field"""
  creditCardSnapshotId: ID!

  """
  The credit card ID of the credit card that originally pointed to this snapshot. It may or may not be pointing to it now
  """
  creditCardId: ID!

  """The associated spreedly token for this credit card information"""
  spreedlyToken: String!

  """The first six digits of the credit card"""
  firstSixDigits: String!

  """Last four digits of the credit card"""
  lastFourDigits: String!

  """Visa, Mastercard, etc"""
  issuer: String!

  """Cardholder name (on card)"""
  nameOnCard: String!

  """Billing Address from Spreedly"""
  billingAddress: Address

  """Expiration Date from Spreedly"""
  expirationDate: ExpirationDate
}

"""Updating a credit card? Use this one!"""
input CreditCardUpdateInput {
  """A new spreedly token is generated whenever a credit card is changed"""
  spreedlyToken: String

  """Deprecated. This data will be fetched from the server."""
  firstSixDigits: String

  """Deprecated. This data will be fetched from the server."""
  lastFourDigits: String

  """
  Whether the creditCard should the be default creditCard for this user.
  Only a value of "true" for this field is processed. In order to set isDefault
  to false, set another card to be the default card.
  """
  isDefault: Boolean

  """Billing Address from Spreedly"""
  billingAddress: AddressInput

  """Expiration Date from Spreedly"""
  expirationDate: ExpirationDateInput
}

"""Exchange Rate defined by the currency code and conversion value"""
type CurrencyExchangeRate {
  code: String!
  value: Float!
}

"""An audit log for an internal short link"""
type DashboardsAudit implements Node {
  """The ID of an object"""
  id: ID!
  auditId: ID!

  """The email of the author of this change """
  author: String!
  action: String!
  message: String

  """The table that this audit log corresponds to."""
  type: String!
  target: String!
  ts: DateTime!
}

"""Dash notification"""
type DashNotification implements Node {
  """The ID of an object"""
  id: ID!

  """Unique identifier for a notification. UUID v4 type"""
  notificationId: ID!

  """Dash affected by this notification"""
  dashName: String!

  """Short description for the notification"""
  description: String!

  """Longer description, can be Markdown"""
  message: String!

  """True if a notification is pinned to top of dash's notifications"""
  pinned: Boolean!

  """Notification startTime. ISO8601 UTC format"""
  startTime: DateTime!

  """
  Notification endTime. ISO8601 UTC format. Can be null for events with no endTime
  """
  endTime: DateTime

  """Notification type, one of ALERT, DISABLED, INFO, MAINTENANCE"""
  type: DashNotificationType!
}

"""Describes input for creating a dash notification"""
input DashNotificationCreateInput {
  """Short description for the notification"""
  description: String!

  """Dash affected by this notification."""
  dashName: String!

  """Longer description, can be Markdown"""
  message: String!

  """
  True if a notification is pinned to top of dash's notifications. Defaults to false
  """
  pinned: Boolean

  """Notification startTime. ISO8601 UTC format. Defaults to current time"""
  startTime: DateTime

  """
  Notification endTime. ISO8601 UTC format. Can be null for events with no endTime. Must be after startTime
  """
  endTime: DateTime

  """Notification type, one of ALERT, DISABLED, INFO, MAINTENANCE"""
  type: String!
}

"""Dash Notification type, one of ALERT, DISABLED, INFO, MAINTENANCE"""
enum DashNotificationType {
  ALERT
  DISABLED
  INFO
  MAINTENANCE
}

"""Describes input for updating a dash notification"""
input DashNotificationUpdateInput {
  """Short description for the notification"""
  description: String

  """Longer description, can be Markdown"""
  message: String

  """True if a notification is pinned to top of dash's notifications."""
  pinned: Boolean

  """Notification startTime. ISO8601 UTC format."""
  startTime: DateTime

  """
  Notification endTime. ISO8601 UTC format. Can be null for events with no endTime. Must be after startTime
  """
  endTime: DateTime

  """Notification type, one of ALERT, DISABLED, INFO, MAINTENANCE"""
  type: String
}

"""ISO 8601-compliant string representing a date"""
scalar DateTime

"""
A common delete status for collections related entities (CollectionRecipes, Collections etc.)
"""
type DeleteStatus {
  status: String!
}

type Droplist {
  userId: ID!
  userEmail: String
  productId: String!
  originalPrice: Int
  notifyAtPrice: Int
  expires: Timestamp
  created: Timestamp
  updated: Timestamp
  removed: Timestamp
  product: Product
  notifications(limit: Int): [DroplistNotification]
  tags: [String!]
  source: DroplistSource
  title: String
  storeId: String
  parentId: String
  variantId: String
  priceCurrent: Int
}

type DroplistAdded implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  items: [Droplist!]!
}

input DroplistAddInput {
  """v3"""
  originalPrice: Int
  notifyAtPrice: Int

  """v4"""
  productId: String
  storeId: String
  parentId: String
  variantId: String
  priceCurrent: Int
  priceToNotify: Int
  priceWhenDroplisted: Int
  watchLength: Int!
  source: DroplistSource = MANUAL
  tags: [String!]
  title: String
}

type DroplistCollection {
  """ID of the collection"""
  collectionId: ID!

  """Name of the collection"""
  collectionName: String!

  """URL of the primary image, that represents the collection"""
  imageUrlPrimary: String

  """
  Structure of low-resolution image URLs (if any exist), that represents the collection
  """
  imageUrlPrimaryTransformed: Object

  """
  Timestamp specifying when the last action occurred (e.g. renaming, adding a new collection)
  """
  updated: Timestamp
}

"""TODO: write resolvers"""
type DroplistExpired implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  items: [Droplist!]!
}

input DroplistExpireInput {
  productData: DroplistExpireInputProductData!
  subject: String
}

input DroplistExpireInputProductData {
  _empty: String
}

input DroplistFilterInput {
  limit: Int
  maxPrice: Int
  minPrice: Int
  offset: Int
  parentIds: [String!]
  productIds: [String!]
  searchTerms: [String!]
  sortBy: DroplistSortBy
  status: DroplistStatus
  storeIds: [String!]
  variantIds: [String!]
}

input DroplistGetInput {
  parentId: String!
  storeId: String!
  variantId: String
}

input DroplistHolidayInput {
  categories: [String!]!
  emailType: String!
  preheader: String!
  subject: String!
  users: [DroplistHolidayInputUsers!]!
  usersData: DroplistHolidayInputUsersData!
}

input DroplistHolidayInputUsers {
  userEmail: String!
  userId: String!
}

input DroplistHolidayInputUsersData {
  _empty: String
}

input DroplistInput {
  productData: DroplistInputProductData!
  subject: String
}

input DroplistInputProductData {
  _empty: String
}

type DroplistNotification {
  """v3"""
  userId: ID!
  productId: String!
  eventId: String
  notified: Timestamp
  notifyAtPrice: Int
  originalPrice: Int
  city: String
  country: String
  region: String

  """v4"""
  storeId: String
  parentId: String
  variantId: String
  priceToNotify: Int
  priceWhenDroplisted: Int
  priceWhenNotified: Int
}

input DroplistNotificationInput {
  """v3"""
  notifyAtPrice: Int
  originalPrice: Int
  city: String
  country: String
  region: String
  eventId: String
  droplistCreated: Timestamp

  """v4"""
  storeId: String
  parentId: String
  variantId: String
  priceToNotify: Int
  priceWhenDroplisted: Int
  priceWhenNotified: Int
}

input DroplistPriceDropInput {
  productData: DroplistPriceDropInputProductData!
  subject: String
}

input DroplistPriceDropInputProductData {
  _empty: String
}

type DroplistRemove {
  productId: String!
  product: Product!
}

input DroplistRemoveInput {
  productId: String
  storeId: String
  parentId: String
  variantId: String
}

"""Object returned after rewatching all expiring products"""
type DroplistRewatchAll {
  updatedCount: Int
  success: Boolean!
}

enum DroplistSortBy {
  BESTDEAL
  DATE
  EXPIRINGSOON
  MOST_TIME_REMAINING
  PRICEHITOLO
  PRICELOTOHI
  RECENTLYADDED
}

enum DroplistSource {
  MANUAL
  REWATCH
  SYNC
}

enum DroplistStatus {
  ACTIVE
  ACTIVE_AND_EXPIRED
  EXPIRED
  REMOVED
}

type DroplistTag {
  tag: String
  productIds: [String]
}

input DroplistTagsInput {
  status: DroplistStatus
}

input DroplistUpdateInput {
  """v3"""
  notifyAtPrice: Int

  """v4"""
  productId: String!
  priceToNotify: Int
  watchLength: Int
  tags: [String!]
}

input EmailChangeInput {
  categories: [String!]
  emailAddress: String!
  token: String!
  userId: String
}

type EmailProcessorTask {
  topic: String!
  message: Object!
}

"""
Message is schema-less because each pub-sub message could contain different properties
"""
input EmailProcessorTaskInput {
  topic: String!
  message: Object!
}

type EmailSubscriptions {
  accountUpdates: Boolean
  cartNotifications: Boolean
  droplist: Boolean
  features: Boolean
  insiderDeals: Boolean
}

type EmailUnsubscribes {
  accountUpdates: Boolean!
  cartNotifications: Boolean!
  droplist: Boolean!
  features: Boolean!
  insiderDeals: Boolean!
}

"""An A/B test"""
type Experiment implements Node {
  """The ID of an object"""
  id: ID!
  experimentId: ID!
  name: String!
  active: Boolean!
  archived: Boolean!
  createdAt: Timestamp!
  winningVariantName: String
  feature: String
  description: String
  sampleSize: Int!
  totalBucketedUsers: Int!
  startDate: Timestamp!
  endDate: Timestamp!
  populationAllocation: Int!
  targetPlatform: [String!]!
  targetBrowser: [String!]!
  targetCountry: [String!]!
  targetExtensionVersionMin: String
  targetAccountAgeMin: Int
  periscopeReportLink: String
  experimentRunner: String!
  variants: [ExperimentVariant!]!
}

"""Fields available for creation of a experiment"""
input ExperimentCreateInput {
  name: String!
  feature: String
  description: String
  sampleSize: Int!
  startDate: Timestamp!
  endDate: Timestamp!
  populationAllocation: Int!
  targetPlatform: [String!]!
  targetBrowser: [String!]!
  targetCountry: [String!]!
  targetExtensionVersionMin: String
  targetAccountAgeMin: Int
  periscopeReportLink: String
  experimentRunner: String!
  variants: [ExperimentVariantCreateInput!]!
}

"""Fields available for updating an experiment"""
input ExperimentUpdateInput {
  name: String
  active: Boolean
  archived: Boolean
  feature: String
  description: String
  sampleSize: Int
  startDate: Timestamp
  endDate: Timestamp
  populationAllocation: Int
  targetPlatform: [String!]
  targetBrowser: [String!]
  targetCountry: [String!]
  targetExtensionVersionMin: String
  targetAccountAgeMin: Int
  variants: [ExperimentVariantCreateInput!]
  totalBucketedUsers: Int
  periscopeReportLink: String
  winningVariantName: String
}

"""Variant in an A/B testing Experiment"""
type ExperimentVariant implements Node {
  """The ID of an object"""
  id: ID!
  experimentId: ID!
  name: String!
  buckets: [Int!]!
}

input ExperimentVariantCreateInput {
  name: String!
  buckets: [Int!]!
}

"""Represents a credit card expiration date"""
type ExpirationDate {
  """Expiration Date Month"""
  month: Int!

  """Expiration Date Year"""
  year: Int!
}

input ExpirationDateInput {
  """Expiration Date Month"""
  month: Int!

  """Expiration Date Year"""
  year: Int!
}

input ExploreMetaInput {
  limit: Int
  offset: Int
  userId: ID
}

type ExtensionStats {
  ts: Timestamp!
  name: String!
  rating: Float!
  reviews: Int!
  users: Int!
}

"""Deprecated. Do not use."""
type Features {
  title: String @deprecated(reason: "Deprecated. Do not use.")
  text: String @deprecated(reason: "Deprecated. Do not use.")
}

type FilterReason {
  excluded: Boolean!
  goDaddyButNotCJ: Boolean
  blacklisted: Boolean!
  banned: Boolean!
  notStarted: Boolean!
  noSources: Boolean!
  expired: Boolean
}

"""Response from a Find Savings initiation"""
type FindSavingsResponse {
  """The new active cart"""
  activeCart: Cart

  """The updated cart that 'Find Savings' was called with"""
  cart: Cart

  """Any errors returned when initiating/running find savings"""
  errors: [CheckoutError!]
}

type Footer {
  value: String!
  action: String
  testID: String
  style: Object
  collapsedValue: String
  arrow: Boolean
}

"""TODO: write resolvers"""
type FoundSavings implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  storeId: ID!

  """
  This schema is found in /stores/schema.graphql
  From this, we want `name`
  """
  store: Store!
  discount: Int
}

type FullOffer {
  userId: String!
  storeId: String!
  offerId: String!
  campaignId: ID!
  created: Timestamp!
  expires: Timestamp!
  value: Int!
  used: Boolean!
  endDate: Timestamp
  minimumOrderValue: Int!
  startDate: Timestamp!
  type: StoreOfferType!
  storeName: String!
}

type GiftCardRedeem implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  totalGold: Int!

  """get `name` for each store"""
  stores: [Store!]!
}

type GlobalActivity {
  eventType: String!
  score: Int!
  count: Int
  storeId: String
  merchId: String
  brand: String
  category: String
  title: String
  productId: String
  description: String
  price: Int
  createdAt: Timestamp
  eventAt: Timestamp
  resultData: String
  product: Product
  store: Store
}

type GlobalActivityResultSet {
  results: [GlobalActivity!]!
  totalResultCount: Int!
}

"""TODO: write resolvers"""
type GoldActivated implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  storeIds: [ID!]!

  """
  from transactions/storesCashback.graphql
  get `minPercent` and `maxPercent` from each store
  """
  goldPercentages: [StoresCashbackOfferResponse]!

  """get name from each store"""
  stores: [Store!]!
}

"""TODO: write resolvers"""
type GoldBonusEarned implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  goldValue: Int!
  storeId: ID!

  """get `name`"""
  store: Store!
}

type GoldCleared implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  storeId: ID!
  goldValue: Int!

  """get `name`"""
  store: Store!
}

type GoldEarned implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  storeId: ID!
  purchaseTime: Timestamp!
  goldValue: Int!

  """get `name`"""
  store: Store!
}

type Header {
  title: ActionText
  logo: Image
  icon: Icon
  subtitle: [Subtitle]
  couponCount: Int
}

input HgConfInput {
  categories: [String!]
  emailAddress: String!
  externalCreated: Float!
  gold: Float!
  percent: Float!
  store: String!
  storeIsFlatFee: Boolean
  token: String!
  userId: String!
  userPoints: Float!
}

type HiddenReason {
  dbHidden: Boolean!
  rmnmNewCode: Boolean
  expired: Boolean
}

"""A single order from the Honey app (may contain multiple stores)"""
type HoneyOrder {
  """Primary key field; the user to whom this order belongs"""
  userId: ID!

  """The Honey-generated order ID"""
  honeyOrderId: ID!

  """The cart for this order"""
  cart: Cart

  """Timestamp of when checkout was completed"""
  checkoutCompletedAt: Timestamp

  """Each CartOrder represents a single store order"""
  cartOrders: [CartOrder]!

  """The associated TwoTap Purchase ID"""
  twoTapPurchaseId: String

  """A message from TwoTap regarding this purchase"""
  twoTapPurchaseMessage: String
}

"""Input parameters for querying for a user's orders"""
input HoneyOrderQuery {
  """A honey-generated order ID"""
  honeyOrderId: ID

  """The TwoTap Purchase ID"""
  twoTapPurchaseId: String
}

"""Query fields for User.honeyOrders"""
input HoneyOrdersQuery {
  limit: Int!
  offset: Int
}

input HoneyOrderUpdateInput {
  """Timestamp of when checkout was completed"""
  checkoutCompletedAt: Timestamp

  """A message from TwoTap regarding this purchase"""
  twoTapPurchaseMessage: String
}

type Icon {
  type: String!
  color: String
}

type Image {
  uri: String!
  action: String
  testID: String
  style: Object
  border: Boolean
}

input InputSearchTypeOverride {
  author: String
  reason: String
  search: String
  searchType: String
  searchTypeMetadata: String
  searchTypeVersion: String
}

input InputTestGroup {
  groupId: ID
  groupName: String
  min: Int
  max: Int
}

input InputTestInfo {
  testName: String
  testStartDate: String
  testEndDate: String
  disabled: Boolean
}

input InputTestSetting {
  test: InputTestInfo!
  groups: [InputTestGroup]
}

input InstallReminderInput {
  categories: [String!]
  customEmailType: String
  userEmail: String!
  userId: String
  visitorId: String
}

"""A short link for internal use"""
type InternalShortLink implements Node {
  """The ID of an object"""
  id: ID!

  """Unique identifier that can be used to access this link"""
  name: String!
  user: User!

  """The url that this link redirects to"""
  url: String!

  """The time this link was created"""
  created: DateTime!

  """The last time this link was used"""
  lastUsed: DateTime

  """The id of the user who created this link"""
  userId: String!
}

"""States of inventory stock availablity"""
enum InventoryType {
  all
  inStock
  oos
}

type Invite implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
}

input IosWelcomeInput {
  userEmail: String!
  userId: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

input LendingAchPaymentReturnInput {
  bankName: String!
  email: String!
  loanId: String!
  nickname: String!
  subject: String
  userId: String!
}

input LendingFirstPaymentReminderInput {
  amount: String!
  dateDue: String!
  email: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingIdentityConfirmedInput {
  email: String!
}

input LendingInterchangePaymentReturnInput {
  cardNumber: String!
  cardType: String!
  email: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingInvalidDocumentProcessedInput {
  email: String!
}

input LendingLoanAdverseActionInput {
  email: String!
  loanAdverseActionLink: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingLoanAgreementInput {
  email: String!
  loanAgreementLink: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingLoanReactivationInput {
  email: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingMerchantRefundInput {
  amount: String!
  email: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingOverpaymentCreditFailureInput {
  email: String!
  loanId: String!
}

input LendingOverpaymentCreditInput {
  amount: String!
  email: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingPaymentCancelInput {
  amount: String!
  email: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingPaymentCreateInput {
  amount: String!
  email: String!
  loanId: String!
  processOnTimestamp: Float!
  processingStatusMsg: String!
  subject: String
  userId: String!
}

input LendingPaymentDatePushedInput {
  dateDue: String!
  email: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingPaymentFailureInput {
  email: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingPaymentPastDueInput {
  amount: String!
  email: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingRequestIdentityVerificationInput {
  email: String!
}

input LendingSecondPaymentReminderInput {
  amount: String!
  dateDue: String!
  email: String!
  loanId: String!
  subject: String
  userId: String!
}

input LendingSystemDisabledAutopayInput {
  email: String!
  loanId: String!
  subject: String
  userId: String!
}

enum ListTypeEnum {
  EXCLUDE
  INCLUDE
}

type Loan {
  id: String!
  userId: String!
  status: String!
  amountCents: Int!
  creditCardNumber: Int!
  creditCardExpMonth: Int!
  creditCardExpYear: Int!
  creditCardCVV: Int!
  createdAt: String
  updatedAt: String
}

input ManualTransactionInput {
  value: Int!
  manualDescription: String
  manualComment: String
}

"""types for snippets shared across templates"""
type Meta {
  cardId: String!
  cardType: String!
  cardTs: Timestamp!
  modelId: String!
  cardPlatform: Int

  """weight overflows 32-bit signed integer, requires Timestamp type"""
  weight: Timestamp
  recommendationId: String!
  trackingData: Object!
  productId: String
  productName: String
  source: String
  storeName: String
  storeId: String
  offerExpiration: Int
  offerGoldValue: Int
  productCurrentPrice: Int
  productListPrice: Int
  productParentId: String
  productVariantId: String
}

type MobileWaitlist {
  """TODO docs"""
  position: Int
  userId: ID!
  waitlisted: Boolean!
}

input MobileWaitlistAccessInput {
  customEmailType: String
  email: String!
  subject: String
  userId: String
  visitorId: String
}

type Mutation {
  """Add AltOrderNumber"""
  addAltOrderNumber(orderId: ID!, orderNumber: String!): AltOrderNumber!
  addCarrierRegex(walletEmailRegexCarrier: CarrierRegexAddInput!): CarrierRegexes!

  """Add CartOrder"""
  addCartOrder(userId: ID!, order: CartOrderAddInput!): CartOrder!

  """
  Upsert CartStoreAccount @deprecated(reason: "Please use 'getOrCreateCartStoreAccount' instead.")
  """
  addCartStoreAccount(userId: ID!, cartStoreAccount: CartStoreAccountAddInput!): CartStoreAccount!

  """Add a credit card"""
  addCreditCard(userId: ID!, creditCardInput: CreditCardAddInput!): CreditCard!

  """
  Adds a cart order for a guest user for the purposes of find savings in v1 cart.
  """
  addGuestCartOrder(guestUserId: ID!, order: CartOrderAddInput!): CartOrder!

  """Add OrderEmail"""
  addOrderEmail(userId: ID!, orderEmail: OrderEmailAddInput!): OrderEmail!
  addOrderPackage(orderId: ID!, orderPackage: OrderPackageAddInput!): OrderPackage!

  """Add senderDomain"""
  addSenderDomain(senderDomain: AddSenderDomainInput!): SenderDomain!

  """Add a shipping address"""
  addShippingAddress(userId: ID!, shippingAddress: ShippingAddressAddInput!): ShippingAddress!
  addWalletEmailRegex(walletEmailRegex: WalletEmailRegexInsertInput!): WalletEmailRegex!
  addWalletEmailRegexMask(regexId: String!, storeId: String!): WalletEmailRegexMask

  """
  Performs verification on user id and will award user checkout related gold
  """
  awardUserCheckoutOrderGold(
    userId: ID!

    """Use to prevent (this) pending order from failing the verification step"""
    honeyOrderId: ID
  ): Boolean!

  """Perform a checkout"""
  checkout(userId: ID!, cartId: ID!, input: CheckoutInput!): CheckoutResponse!

  """
  Claims the purchase. Returns an error if that purchase has already been claimed.
  """
  claimPurchase(userId: ID!, purchaseId: ID!): TwoTapPurchase

  """
  Creates a cart to remediate the errors from the cartOrder provided. Checkout with this cart to remediate errors.
  """
  createRemediationCart(
    userId: ID!
    cartOrderId: ID!

    """
    If true, will remediate all cartOrders in this honeyOrder with the same error type
    """
    remediateSimilarErrors: Boolean
  ): Cart

  """
  Returns a unique session token to use with subsequent Google Places API calls
  """
  createSessionToken: ID!

  """
  Publish a PubSub message, which will be pulled in by the wallet task email processor
  """
  createWalletEmailTask(processorTask: EmailProcessorTaskInput!): EmailProcessorTask!
  deleteCarrierRegex(regexId: String!, carrierName: CarrierTypeEnum!): Boolean!

  """Delete a credit card"""
  deleteCreditCard(userId: ID!, creditCardId: ID!): Boolean!

  """Delete a shipping address"""
  deleteShippingAddress(userId: ID!, shippingAddressId: ID!): Boolean!
  deleteWalletEmailRegex(regexId: String!): Boolean!
  deleteWalletEmailRegexMask(maskId: String!, regexId: String!): Boolean

  """Fetches shipping estimate info from twotap and writes it to DB"""
  fetchAndUpdateShippingEstimates(sessionInput: CartApiSessionQueryInput!, cartId: ID!, transactionId: String): Cart

  """Creates a shippable address to be used later"""
  generateShippableAddress(userIpAddress: String!): Boolean!

  """
  Gets the active store account email, or creates a new one and returns that
  """
  getOrCreateCartStoreAccount(userId: ID!): CartStoreAccount!

  """Merge items from errored orders into the active cart"""
  mergeCartFromErroredHoneyOrder(userId: ID!, honeyOrderId: ID!): Cart!

  """
  Takes the items from cartOne and merges them into cartTwo. Unsets cartOne as the active cart.
  """
  mergeCarts(cartOneSessionInput: CartApiSessionQueryInput!, cartOneCartQuery: CartQuery!, cartTwoSessionInput: CartApiSessionQueryInput!, cartTwoCartQuery: CartQuery!): Cart!

  """Proxies the request to Two Tap's POST /purchase/confirm endpoint"""
  proxyPostPurchaseConfirm(userId: ID!, purchaseId: ID!): TwoTapApiResponse

  """
  Initiate 'Find Savings' for a logged in or logged out (guest) user's cart. For
  a guest user, a 'shippingAddress' is generated using the request
    ipAddress' geolocation
  """
  runFindSavings(sessionInput: CartApiSessionQueryInput!, cartId: ID!): FindSavingsResponse!

  """Sends a checkoutConfirmed email with pre-processing"""
  sendCheckoutOrderConfirmedFromCartApi(userId: ID!, orderId: ID!): Boolean

  """Associate cartOrderProducts with an orderPackage"""
  setOrderPackageProducts(userId: ID!, cartOrderId: ID!, orderPackageId: ID!, cartOrderProductIds: [ID!]!): OrderPackage!

  """Start checkout funnel and persist product offers"""
  startCheckout(sessionInput: CartApiSessionQueryInput!, cartId: ID!): StartCheckoutResponse!

  """
  Transfer a cart from a logged out user (device id) to a logged in user (userId)
  """
  transferCart(deviceId: ID!, cartId: ID!, userId: ID!): Cart

  """Update the given cart with the given data"""
  updateCart(sessionInput: CartApiSessionQueryInput!, cartId: ID!, transactionId: String, updates: CartUpdateInput): Cart

  """Update a cart item"""
  updateCartItem(sessionInput: CartApiSessionQueryInput!, cartId: ID!, transactionId: String, storeId: ID!, productId: ID!, updates: CartItemUpdateInput): CartItem

  """Update CartOrder"""
  updateCartOrder(userId: ID!, orderId: ID!, order: CartOrderUpdateInput!): CartOrder!

  """Updates a CartOrderPackage"""
  updateCartOrderProduct(userId: ID!, orderId: ID!, id: ID!, updates: CartOrderProductUpdateInput!): CartOrderProduct!

  """Update a cartStore"""
  updateCartStore(sessionInput: CartApiSessionQueryInput!, cartId: ID!, storeId: ID!, transactionId: String, updates: CartStoreUpdateInput): CartStore
  updateCheckoutSupport(checkoutSupport: CheckoutSupportUpdateInput!): CheckoutSupport!

  """Update a credit card"""
  updateCreditCard(userId: ID!, creditCardId: ID!, creditCardInput: CreditCardUpdateInput): CreditCard!

  """Updates the guests cart order"""
  updateGuestCartOrder(guestUserId: ID!, orderId: ID!, order: CartOrderUpdateInput!): CartOrder!

  """Update a honeyOrder"""
  updateHoneyOrder(userId: ID!, honeyOrderId: ID!, updates: HoneyOrderUpdateInput!): HoneyOrder!

  """
  Update a single OrderEmail record. Exposed to Data API3, so it requires userId for authorization.
  """
  updateOrderEmail(userId: ID!, orderEmailId: ID!, orderEmail: OrderEmailUpdateInput!): OrderEmail!

  """Update OrderEmails by orderEmailId"""
  updateOrderEmails(orderEmails: [OrderEmailUpdateInput]!): [OrderEmail]!
  updateOrderPackage(orderId: ID!, orderPackageId: ID!, orderPackage: OrderPackageUpdateInput!): OrderPackage! @deprecated(reason: "Use updateOrderPackages")
  updateOrderPackages(orderPackageUpdates: [BatchOrderPackageUpdateInput!]!): [OrderPackage!]!

  """Update senderDomain"""
  updateSenderDomain(senderDomain: UpdateSenderDomainInput!): SenderDomain!

  """Update shipping address"""
  updateShippingAddress(userId: ID!, shippingAddressId: ID!, shippingAddress: ShippingAddressUpdateInput): ShippingAddress!
  updateWalletEmailRegex(regexId: String!, updateFields: WalletEmailRegexUpdateInput!): [WalletEmailRegex]!

  """Insert a product into the cart or update its quantity"""
  upsertCartItemQuantity(sessionInput: CartApiSessionQueryInput!, cartId: ID!, storeId: ID!, productId: ID!, quantity: Int!): Cart
  upsertCartSession(userId: ID!, items: [Object]): CartSession

  """Upserts a CartStoreShippingEstimates Object"""
  upsertCartStoreShippingEstimates(sessionInput: CartApiSessionQueryInput!, cartId: ID!, storeId: ID!, shippingSpeed: String!, updates: CartStoreShippingEstimatesUpsertInput!): CartStoreShippingEstimates

  """Upserts a guests cart session"""
  upsertGuestCartSession(guestUserId: ID!, items: [Object]): CartSession
  creditCardOfferCreateUserAction(userId: ID!, creditCardOfferId: ID!, action: CreditCardOfferUserActionType!): CreditCardOfferUserAction

  """Create a new dash notification. Returns the created dash notification"""
  createDashNotification(notification: DashNotificationCreateInput!): DashNotification!

  """Creates an internal short link"""
  createInternalShortLink(name: String!, url: String!): InternalShortLink!

  """Deletes an internal short link"""
  deleteInternalShortLink(name: String!): Boolean!

  """
  Disable a dash notification. Returns true if the operation was successful and throws an error otherwise
  """
  disableDashNotification(notificationId: ID!): DashNotification!

  """
  Update an existing dash notification. Disables the notification and creates a
  new one for active notifications, directly updates otherwise
  """
  updateDashNotification(notificationId: ID!, notificationUpdate: DashNotificationUpdateInput!): DashNotification!

  """Updates an internal short link"""
  updateInternalShortLink(name: String!, url: String): InternalShortLink!
  addToDroplist(userId: ID!, meta: [DroplistAddInput!]!, overwrite: Boolean = true): [Droplist!]!
  removeDroplist(userId: ID!, meta: [DroplistRemoveInput!]!): [DroplistRemove!]!

  """Update expiry date on products about to expire"""
  rewatchAllExpiresDroplist(userId: ID!, windowStart: String!, windowEnd: String!): DroplistRewatchAll!
  updateDroplist(userId: ID!, meta: [DroplistUpdateInput!]!): Boolean!

  """Creates a new A/B testing experiment"""
  insertExperiment(experiment: ExperimentCreateInput!): Experiment!

  """Updates mutable experiment properties"""
  updateExperiment(experimentId: ID!, experiment: ExperimentUpdateInput!): Experiment!
  createCollection(collectionRecipeId: ID!, collection: CollectionCreateInput!): Collection! @deprecated(reason: "Use `createCollectionV2` instead")
  createCollectionPreference(collectionRecipeId: ID!, collectionId: ID!, collectionPreference: CollectionPreferenceCreateInput!): CollectionPreference! @deprecated(reason: "Use `createCollectionPreferenceV2` instead")
  createCollectionPreferenceV2(collectionId: ID!, collectionPreference: CollectionPreferenceCreateInput!): CollectionPreference!
  createCollectionRecipe(collectionRecipe: CollectionRecipeCreateInput!): CollectionRecipe!
  createCollectionV2(collection: CollectionCreateInputV2!): CollectionUpsertOutput!
  deleteCollection(collectionRecipeId: ID!, collectionId: ID!): Object @deprecated(reason: "Use `deleteCollectionV2` instead")
  deleteCollectionPreference(collectionRecipeId: ID!, collectionId: ID!, preferenceId: ID!): Object @deprecated(reason: "Use `deleteCollectionPreferenceV2` instead")
  deleteCollectionPreferenceV2(collectionId: ID!, preferenceId: ID!): DeleteStatus!
  deleteCollectionRecipe(collectionRecipeId: ID!): Object
  deleteCollectionV2(collectionId: ID!): DeleteStatus!

  """
  Refreshing process fills in the latest set of products for Mobile and Desktop platforms.
  """
  refreshCollections(collectionIds: [ID!]!): [Collection!]!
  updateCollection(collectionRecipeId: ID!, collectionId: ID!, collection: CollectionUpdateInput!): Collection! @deprecated(reason: "Use `updateCollectionV2` instead")
  updateCollectionPreferences(collectionPreferences: [CollectionPreferenceUpdateInput!]!): CollectionPreferenceUpdates!
  updateCollectionPreferencesV2(collectionPreferences: [CollectionPreferenceUpdateInputV2!]!): CollectionPreferenceUpdatesV2!
  updateCollectionRecipe(collectionRecipeId: ID!, collectionRecipe: CollectionRecipeUpdateInput!): CollectionRecipe!
  updateCollectionV2(collectionId: ID!, collection: CollectionUpdateInputV2!): CollectionUpsertOutput!
  createLoan(userId: ID!, amountCents: Int!): Loan!

  """
  Send email with 'Add Store Support' form (www.joinhoney.com/addstore) info to Luke Szendiuch at 'luke@joinhoney.com'
  """
  mailAddStoreSupport(payload: AddStoreSupportInput!): String!

  """
  After user completes the Ambassador application from
  https://www.joinhoney.com/ambassadors/application, send a plain text email
  with the application info to ambassadors@joinhoney.com.
  """
  mailAmbassadorApplication(payload: AmbassadorApplicationInput!): String!

  """
  After user is approved/denied as an ambassador, send them a welcome/rejection
  email letting them know they've been accepted into/denied from the program.
  """
  mailAmbassadorDecision(payload: AmbassadorDecisionInput!): String!

  """Explain to users about the difference betw. app vs. extension."""
  mailAppDifferentiator(payload: AppDifferentiatorInput!): String!

  """Send email to users who visited a travel site other than booking.com."""
  mailBookingEmailTrigger(payload: BookingEmailTriggerInput!): String!

  """Sends a reminder email to user about items waiting in the cart."""
  mailCheckoutAbandonedCart(payload: CheckoutAbandonedCartInput!): String!

  """Sends an email to a user after a price drop in their cart."""
  mailCheckoutCartPriceDrop(payload: CheckoutCartPriceDropInput!): String!

  """Sends an email to a user after successful find savings call."""
  mailCheckoutFoundSavings(payload: CheckoutFoundSavingsInput!): String!

  """
  Sends an email to a user when an order they placed failed for some reason.
  """
  mailCheckoutOrderCanceled(payload: CheckoutOrderCanceledInput!): String!

  """Sends an email to a user when an order they placed is confirmed."""
  mailCheckoutOrderConfirmed(payload: CheckoutOrderConfirmedInput!): String!

  """Sends an email to a user when an order they placed is delivered."""
  mailCheckoutOrderDelivered(payload: CheckoutOrderDeliveredInput!): String!

  """Sends an email to a user when they place a honeyOrder."""
  mailCheckoutOrderPlaced(payload: CheckoutOrderPlacedInput!): String!

  """Sends an email to a user when an order they placed receives a refund."""
  mailCheckoutOrderRefund(payload: CheckoutOrderRefundInput!): String!

  """Sends an email to a user when an order they placed is shipped."""
  mailCheckoutOrderShipped(payload: CheckoutOrderShippedInput!): String!

  """
  Notifies a batch of users that item(s) on their droplist have dropped in price.
  """
  mailDroplist(payload: DroplistInput!): String!

  """
  Notifies a batch of users that item(s) on their droplist are about to expire.
  """
  mailDroplistExpire(payload: DroplistExpireInput!): String!

  """Remind users to use Droplist over the holidays."""
  mailDroplistHoliday(payload: DroplistHolidayInput!): String!

  """
  Notifies a batch of users that item(s) on their droplist have dropped in price.
  """
  mailDroplistPriceDrop(payload: DroplistPriceDropInput!): String!

  """Send email change email."""
  mailEmailChange(payload: EmailChangeInput!): String!

  """Send Honey Gold confirmation email."""
  mailHgConf(payload: HgConfInput!): String!

  """Send an email to remind registered users to install honey (reminder)."""
  mailInstallReminder(payload: InstallReminderInput!): String!

  """Send welcome email to new mobile users."""
  mailIosWelcome(payload: IosWelcomeInput!): String!

  """Send an email notifying user of their payment ACH Return."""
  mailLendingAchPaymentReturn(payload: LendingAchPaymentReturnInput!): String!

  """
  Send an email notifying user of their payment reminder 5 days before installment is due.
  """
  mailLendingFirstPaymentReminder(payload: LendingFirstPaymentReminderInput!): String!

  """
  Notify the user that their identity is confirmed and that they may proceed with their loan application
  """
  mailLendingIdentityConfirmed(payload: LendingIdentityConfirmedInput!): String!

  """Send an email notifying user that their interchange payment returned."""
  mailLendingInterchangePaymentReturn(payload: LendingInterchangePaymentReturnInput!): String!

  """
  Send an email notifying a user that their document was processed, but the document was invalid.
  """
  mailLendingInvalidDocumentProcessed(payload: LendingInvalidDocumentProcessedInput!): String!

  """Send an email notifying user of their loan denial."""
  mailLendingLoanAdverseAction(payload: LendingLoanAdverseActionInput!): String!

  """Send an email notifying user of their loan agreement."""
  mailLendingLoanAgreement(payload: LendingLoanAgreementInput!): String!

  """
  Send an email notifying a user that their loan is active again due to a failed payment.
  """
  mailLendingLoanReactivation(payload: LendingLoanReactivationInput!): String!

  """
  Send an email notifying user that their loan balance will be adjusted due to a mechant refund or cancellation.
  """
  mailLendingMerchantRefund(payload: LendingMerchantRefundInput!): String!

  """
  Send an email notifying user that their payment method will be credited due to
  a merchant refund which resulted in an overpayment.
  """
  mailLendingOverpaymentCredit(payload: LendingOverpaymentCreditInput!): String!

  """
  Notify the user that their overpayment refund could not be processed and was returned.
  """
  mailLendingOverpaymentCreditFailure(payload: LendingOverpaymentCreditFailureInput!): String!

  """Send an email notifying user of their payment cancellation."""
  mailLendingPaymentCancel(payload: LendingPaymentCancelInput!): String!

  """Send an email notifying user of their payment creation."""
  mailLendingPaymentCreate(payload: LendingPaymentCreateInput!): String!

  """
  Send an email notifying user that their payment date has been pushed 7 days
  """
  mailLendingPaymentDatePushed(payload: LendingPaymentDatePushedInput!): String!

  """Send an email notifying user of their payment failure."""
  mailLendingPaymentFailure(payload: LendingPaymentFailureInput!): String!

  """Send an email notifying user that their payment is past due."""
  mailLendingPaymentPastDue(payload: LendingPaymentPastDueInput!): String!

  """
  Send an email notifying user to upload identification for identity verification
  """
  mailLendingRequestIdentityVerification(payload: LendingRequestIdentityVerificationInput!): String!

  """
  Send an email notifying user of their payment reminder 1 day before installment is due.
  """
  mailLendingSecondPaymentReminder(payload: LendingSecondPaymentReminderInput!): String!

  """Send an email notifying user that we've disabled autopay."""
  mailLendingSystemDisabledAutopay(payload: LendingSystemDisabledAutopayInput!): String!

  """
  Notifies a user whose position on the waitlist is now below the cutoff for access to the mobile app.
  """
  mailMobileWaitlistAccess(payload: MobileWaitlistAccessInput!): String!

  """Send email to users about new stores to re-engage app users."""
  mailNewStores(payload: NewStoresInput!): String!

  """Send email to users about new stores to re-engage app users."""
  mailNewStoresA(payload: NewStoresAInput!): String!

  """Send email to users about new stores to re-engage app users."""
  mailNewStoresB(payload: NewStoresBInput!): String!

  """Send email to users about new stores to re-engage app users."""
  mailNewStoresC(payload: NewStoresCInput!): String!

  """Send email to users about new stores to re-engage app users."""
  mailNewStoresD(payload: NewStoresDInput!): String!

  """Send email to users about new stores to re-engage app users."""
  mailNewStoresE(payload: NewStoresEInput!): String!

  """Send an email with a link to install Honey."""
  mailOnboardingInstall(payload: OnboardingInstallInput!): String!

  """Send an email with a link to install Honey (growth version)."""
  mailOnboardingInstallGrowth(payload: OnboardingInstallGrowthInput!): String!

  """Sends store offers to users after sign-up."""
  mailOnboardingOffers(payload: OnboardingOffersInput!): String!

  """Send password reset email."""
  mailPasswordReset(payload: PasswordResetInput!): String!

  """Send payout gift card email."""
  mailPayoutGiftCards(payload: PayoutGiftCardsInput!): String!

  """
  Email users who have an product on their Droplist or Cart that just had an offer created for it.
  """
  mailProductOffersNewOffer(payload: ProductOffersNewOfferInput!): String!

  """Send email inviting recipient to use honey through a user referral"""
  mailReferralInvite(payload: ReferralInviteInput!): String!

  """Campaign to win back inactive users"""
  mailResurrectionCampaign(payload: ResurrectionCampaignInput!): String!

  """Send email telling user about pending rewards gold."""
  mailRewardsBonusPending(payload: RewardsBonusPendingInput!): String!

  """Send email to users to install latest version of Honey."""
  mailSafariExtensionUpdateTrigger(payload: SafariExtensionUpdateTriggerInput!): String!

  """
  Send email to users to update their OS and install latest version of Honey.
  """
  mailSafariOsUpdateTrigger(payload: SafariOsUpdateTriggerInput!): String!

  """Monthly merchant newsletter (aka TM+)"""
  mailStoreNewsletter(payload: StoreNewsletterInput!): String!

  """Send tag welcome email with a link to Honey."""
  mailTagWelcome(payload: TagWelcomeInput!): String!

  """Request active users to review Honey on Trustpilot"""
  mailTrustpilotReview(payload: TrustpilotReviewInput!): String!

  """Send wallet auth email (for mobile app)."""
  mailWalletAuth(payload: WalletAuthInput!): String!

  """Send welcome reminder email with a link to install Honey."""
  mailWelcomeReminder(payload: WelcomeReminderInput!): String!
  activateProductOffer(userId: String!, offerId: String!): ProductOfferActivation!

  """Give user available gold for redeeming an offer"""
  awardAvailableOfferGold(info: AwardAvailableOfferGoldInput!): AwardOfferGoldResponse!
  awardManualStoreOffer(userId: ID!, linkedTransactionId: ID!): Transaction!

  """Give user pending gold for redeeming an offer"""
  awardPendingOfferGold(info: AwardPendingOfferGoldInput!): AwardOfferGoldResponse!
  claimStoreOffer(userId: String!, offerId: String!): PendingStoreOffer!
  createOffersCampaign(name: String!, storeId: String!, totalBudget: Int!, remainingBudget: Int, info: OffersCampaignInfoInput): OffersCampaign!
  createOffersProductGroup(campaignId: String!, discountRate: Float, groupValue: String!, groupType: String!, maximumOfferValue: Int): OffersProductGroup! @deprecated(reason: "Use `createProductOffersTemplate` instead")
  createProductOffersCampaign(name: String!, storeId: String!, totalBudget: Int!, startDate: DateTime!, endDate: DateTime!, budgetSpendRate: Int, info: OffersCampaignInfoInput): ProductOffersCampaign!
  createProductOffersTemplate(campaignId: ID!, discountRate: Float!, targetingValue: [String]!, targetingType: String!, maximumOfferValue: Int, active: Boolean): ProductOffersTemplate!
  createStoreOffer(campaignId: String!, value: Int!, type: StoreOfferType!, startDate: Timestamp!, endDate: Timestamp, minimumOrderValue: Int): StoreOffer!

  """
  Returns the active Offer for the given Product. If there are no active Offers,
  a set of business rules are applied to determine whether one should be created.
  """
  getOrCreateProductOffer(storeId: ID!, parentId: ID!): ProductOffer
  updateOfferPushNotification(pushNotification: OfferPushNotificationUpdateInput!): OfferPushNotification!
  updateOffersCampaign(campaignId: ID!, name: String, totalBudget: Int, state: OffersCampaignState, info: OffersCampaignInfoInput): OffersCampaign!

  """Update the status of an Offer Notification"""
  updateOffersNotification(notification: OffersNotificationUpdateInput!): OffersNotification!
  updateOffersProductGroup(campaignId: ID!, groupId: ID!, discountRate: Float!, maximumOfferValue: Int): OffersProductGroup! @deprecated(reason: "Use `updateProductOffersTemplate` instead")
  updateProductOffersCampaign(campaignId: ID!, name: String, totalBudget: Int, state: ProductOffersCampaignState, startDate: DateTime, endDate: DateTime, budgetSpendRate: Int, info: OffersCampaignInfoInput): ProductOffersCampaign!
  updateProductOffersTemplate(campaignId: ID!, templateId: ID!, discountRate: Float, maximumOfferValue: Int, active: Boolean): ProductOffersTemplate!

  """
  Called by a scheduled task to make an order from an external provider for the oldest pending payout gifts.
  """
  createOrder(payoutProvider: String!): Boolean!

  """
  Creates a new payout gift. Called by the website when the user requests to redeem gold.
  """
  createPayoutGift(payoutGift: PayoutGiftInput!): PayoutGift!

  """
  Checks if orders that were made by a call to createOrder mutation are ready to be processed.
  """
  lockOrder(payoutProvider: String!): Boolean!
  resendPayoutGiftCard(userId: ID!, giftId: ID!): String!

  """
  Resends email to a user to inform that a gift card is ready, or that gift cards that belong to a transaction are ready.
  """
  resendPayoutGiftCards(userId: ID!, transactionId: ID!): String!

  """
  Updates the payout gift with ID payoutGiftId, with the fields from PayoutGiftUpdateInput
  """
  updatePayoutGiftByPayoutGiftId(payoutGiftId: ID!, payoutGift: PayoutGiftUpdateInput!): PayoutGift!

  """
  Updates all the payout gifts associated with order payoutOrderId and provider
  payoutProvider, with the fields from PayoutGiftUpdateInput
  """
  updatePayoutGiftsByPayoutOrderId(payoutOrderId: String!, payoutProvider: String!, payoutGift: PayoutGiftUpdateInput!): [PayoutGift!]!

  """
  Updates all the payout gifts associated with transaction payoutTransactionId, with the fields from PayoutGiftUpdateInput
  """
  updatePayoutGiftsByPayoutTransactionId(payoutTransactionId: ID!, payoutGift: PayoutGiftUpdateInput!): [PayoutGift!]!

  """
  Changes the state of a given order ID. This is called when an order is manually approved, locked, etc.
  """
  updatePayoutOrderState(payoutOrderId: ID!, payoutProvider: String!, state: OrderState!): PayoutOrder!

  """Updates a payoutStoreInfo and returns the updated object"""
  updatePayoutStoreInfo(externalId: ID!, payoutProvider: PayoutProviderType!, payoutStoreInfo: PayoutStoreInfoUpdateInput!): PayoutStoreInfo!
  addRemoteConfigurationKey(configKey: RemoteConfigurationKeyInsertInput!): RemoteConfigurationSuccess
  updateRemoteConfigurationKey(platform: String!, key: String!, configKey: RemoteConfigurationKeyUpdateInput!): RemoteConfigurationSuccess

  """create a new test"""
  createTest(setting: InputTestSetting!): Response!

  """delete an existing test"""
  deleteTest(testId: ID!): Response!

  """delete test groups"""
  deleteTestGroups(groupIds: [ID!]!): Response!

  """Update existing search type metadata"""
  searchTypeOverride(data: InputSearchTypeOverride!): SearchTypeOverride!
  updateAliases(type: String!, alias: String, index: String): Object

  """update an existing test"""
  updateTest(testId: ID!, setting: InputTestSetting!): Response!

  """create new test groups or update test groups"""
  upsertTestGroups(testId: ID!, groups: [InputTestGroup!]!): Response!
  createShippingRestriction(storeId: ID!, shippingRestrictionInfo: ShippingRestrictionInput!): ShippingRestrictionType
  deleteShippingRestriction(storeId: ID!, shippingRestrictionId: ID!): Object
  deleteStore(storeId: ID!): Object
  deleteStoreAffiliateLink(storeId: ID!, affiliateLinkId: ID!): Object
  deleteStoreDeal(storeId: ID!, dealId: ID!): Object
  deleteStoreDealExclusion(storeId: ID!, sourceType: StoreDealSourceType!): Object
  deleteStoreDealSource(storeId: ID!, dealId: ID!, sourceType: StoreDealSourceType!): Object

  """Delete a deal tag for a given store deal"""
  deleteStoreDealTag(storeId: ID!, dealId: ID!, dealTag: String!): Object!
  deleteStoreExternalId(storeId: ID!, type: StoreExternalIdType!): Object

  """Delete a store internationalization group for a given storeId"""
  deleteStoreInternationalizationGroup(storeId: ID!): Object

  """Delete a store link given its storeId and a linkId"""
  deleteStoreLink(storeId: ID!, storeLinkId: ID!): Object
  deleteStorePartialURL(storeId: ID!, url: String!): Object
  deleteStoreRemoteModule(storeId: ID!, type: String!): Object
  deleteStoreScrape(storeId: ID!, scrapeType: String!): Object
  deleteStoreSection(storeId: ID!, sectionId: ID!): Object

  """Delete a store tag for a given store"""
  deleteStoreTag(storeId: ID!, storeTag: String!, storeTagType: String!): Boolean!
  deleteStoreUGC(storeId: ID!, code: String!): Object
  incrementStoreDealSuccess(storeId: ID!, bestCode: Boolean, dealCode: String!, discount: Float!, updatedTime: Float): Object
  incrementUGCFailure(storeId: ID!, code: String!): UserGeneratedCoupon
  incrementUGCSuccess(storeId: ID!, code: String!, userId: String!): UserGeneratedCoupon
  insertNewSection(storeId: ID!, sectionType: String!, sectionHeader: String, sectionBody: String): StoreSection!
  insertStore(store: StoreCreateInput!): Store
  insertStoreAffiliateLink(storeId: ID!, affiliateLink: StoreAffiliateLinkInput!): StoreAffiliateLink!
  insertStoreChangelog(storeId: ID!, storeChangelog: StoreChangelogCreateInput!): StoreChangelog
  insertStoreDeal(storeId: ID!, storeDeal: StoreDealCreateInput!): StoreDeal
  insertStoreDealExclusion(storeId: ID!, storeDealExclusion: StoreDealExclusionCreateInput!): StoreDealExclusion
  insertStoreDealSource(storeId: ID!, dealId: ID!, storeDealSource: StoreDealSourceCreateInput!): StoreDealSource

  """Insert a deal tag for a given store deal"""
  insertStoreDealTag(storeId: ID!, dealId: ID!, dealTag: String!): Object!
  insertStoreExternalId(storeId: ID!, externalId: StoreExternalIdCreateInput!): StoreExternalId

  """Insert a store internationalization group for a given store"""
  insertStoreInternationalizationGroup(storeId: ID!, parentStoreId: ID!, useParentDetails: Boolean!, useParentTips: Boolean!): StoreInternationalizationGroup!

  """Insert a store link for a given store"""
  insertStoreLink(storeId: ID!, storeLinkType: String!, storeLinkUrl: String!): StoreLink!
  insertStorePartialURL(storeId: ID!, partialURL: StorePartialURLCreateInput!): StorePartialURL
  insertStoreRemoteModule(storeId: ID!, remoteModule: StoreRemoteModuleCreateInput!): StoreRemoteModule
  insertStoreSavings(storeId: ID!, discount: Float): Object
  insertStoreScrape(storeId: ID!, scrape: StoreScrapeCreateInput!): StoreScrape

  """Insert a store tag for a given store"""
  insertStoreTag(storeId: ID!, storeTag: String!, storeTagType: String!): Object!
  insertStoreUGC(storeId: ID!, ugcDef: UserGeneratedCouponInputType!): UserGeneratedCoupon
  reactivateStoreAffiliateLink(storeId: ID!, affiliateLinkId: ID!): Object
  setStorePartialURLs(storeId: ID!, partialURLs: [StorePartialURLCreateInput!]!): Object
  updateSectionBody(storeId: ID!, sectionId: ID!, sectionBody: String!): StoreSection!
  updateSectionHeader(storeId: ID!, sectionId: ID!, sectionHeader: String!): StoreSection!
  updateShippingRestriction(storeId: ID!, shippingRestrictionId: ID!, shippingRestrictionInfo: ShippingRestrictionInput!): Object
  updateStore(storeId: ID!, store: StoreUpdateInput!, internalHoneyUserName: String): Object
  updateStoreAffiliateLink(storeId: ID!, affiliateLinkId: ID!, affiliateLink: StoreAffiliateLinkInput!): Object
  updateStoreDeal(storeId: ID!, dealId: ID!, storeDeal: StoreDealUpdateInput!): Object
  updateStoreDealSource(storeId: ID!, dealId: ID!, sourceType: StoreDealSourceType!, storeDealSource: StoreDealSourceUpdateInput!): Object

  """Update the deal tags for a given store deal"""
  updateStoreDealTags(storeId: ID!, dealId: ID!, dealTags: [String!]!): Object!
  updateStoreExternalId(storeId: ID!, type: StoreExternalIdType!, externalId: StoreExternalIdUpdateInput!): Object

  """Update a store internationalization group for a given store"""
  updateStoreInternationalizationGroup(storeId: ID!, parentStoreId: ID!, useParentDetails: Boolean!, useParentTips: Boolean!): StoreInternationalizationGroup!

  """
  Update a store link for a given store, providing updated type and url fields
  """
  updateStoreLink(storeId: ID!, storeLinkId: ID!, storeLinkType: String!, storeLinkUrl: String!): StoreLink!
  updateStorePartialURL(storeId: ID!, url: String!, partialURL: StorePartialURLUpdateInput!): Object
  updateStoreRemoteModule(storeId: ID!, type: String!, remoteModule: StoreRemoteModuleUpdateInput!): Object
  updateStoreScrape(storeId: ID!, scrapeType: String!, scrape: StoreScrapeUpdateInput!): Object

  """Update store tags for a given store"""
  updateStoreTags(storeId: ID!, storeTags: [StoreTagInput!]!): Object!
  updateStoreUGC(storeId: ID!, code: String!, ugcDef: UserGeneratedCouponUpdateType!): Object
  upsertStoreRemoteModule(storeId: ID!, type: String!, remoteModule: StoreRemoteModuleUpsertInput!): Object
  upsertStoreShippingInfo(storeId: ID!, shippingInfo: ShippingInfoInput!): ShippingInfo!

  """
  Creates an AnomalousTransactionLog and returns a boolean True if the record is created sucessfully
  """
  createAnomalousTransactionLog(log: AnomalousTransactionLogInput!): Boolean!
  createCashbackStats(storeId: ID!, data: CashbackStatsCreate!): CashbackStatsResponse!
  createCommissionRate(storeId: ID!, intervalDays: Int!, commissionRate: CommissionRateCreate!): CommissionRateResponse!
  createManualTransaction(userId: ID!, manualTransaction: ManualTransactionInput!): Transaction
  createOnboardingTransaction(userId: ID!, onboardingTransaction: OnboardingTransactionInput!): Transaction
  createPayoutTransaction(userId: ID!, payoutGifts: [PayoutGiftCreateInput!]!, needsReview: Boolean!, transactionId: ID): Transaction
  createReferralStats(userId: ID!): ReferralStats
  createReferralTransaction(referralTransaction: ReferralTransactionInput!): Transaction
  createStoresCashbackOffer(storeId: ID!, cashbackOffer: StoresCashbackOfferCreate!): StoresCashbackOfferResponse!
  createUserPoints(userId: ID!): UsersPoints!
  deleteStoresCashbackOffer(storeId: ID!, started: Timestamp!): Boolean!

  """
  Reconcile a user's usersPoints record with the data in transaction table
  """
  reconcileUsersPointsById(userId: ID!): UsersPoints!

  """
  Revert a payout transaction, void the payout gifts and revert user points
  """
  revertPayoutTransaction(transactionId: ID!, userId: ID!): Transaction!
  revokeAmbassadorReferralCredits(userId: ID!): UsersPoints!
  updateCashbackSettings(update: CashbackSettingsUpdate!): CashbackSettingsResponse!
  updateStoresCashbackOffer(storeId: ID!, started: Timestamp!, cashbackOffer: StoresCashbackOfferUpdate!): StoresCashbackOfferResponse!
  updateTransactionById(transactionId: ID!, transaction: TransactionUpdateInput!): Transaction
  toggleCardVisibility(cardUpdateInput: CardUpdateInput!): Object!
  addAmbassadorRoleGroup(userId: ID!): Boolean!
  addToMobileWaitlist(userId: ID!): MobileWaitlist! @deprecated(reason: "This will only be used for the staged release of the mobile app")
  addUserNoteById(authorId: ID!, userId: ID!, note: String!): UserNote!

  """user review"""
  addUserToReviewList(userId: ID!, ruleSetId: String!): UserInReview!

  """ambassadors"""
  applyForAmbassador(userId: ID!): UserAmbassadorState!
  approveAmbassador(userId: ID!): UserAmbassadorState!
  changeEmail(email: String!, token: String!, newEmail: String!): Boolean!
  createReferral(userId: ID!, referredEmail: String!, referredId: ID): Referral!

  """Create a new Role Group. Returns the created role group"""
  createRoleGroup(groupId: ID!, description: String!, roles: [String!]!): RoleGroup!

  """This is a temporary mutation until data-api is decommissioned."""
  createUserFacebook(audience: String!, facebookId: String!, userId: ID, firstName: String, lastName: String, email: String!, referralToken: String, source: String): AuthenticatedUser!
  declineAmbassador(userId: ID!): UserAmbassadorState!

  """
  Delete Role Group. Returns true if the operation was successful and throws an error otherwise
  """
  deleteRoleGroup(groupId: ID!): Boolean!
  deleteUser(userId: ID!, reason: String): Boolean!
  forceUserLogout(userId: ID!): Boolean!

  """Log user in via Apple ID"""
  logUserInApple(audience: String!, authorizationCode: String!, firstName: String, identityToken: String!, lastName: String, postRegistrationOptions: PostRegistrationOptions, referralToken: String, referrer: Referrer, userId: ID): AuthenticatedUser!
  logUserInEmail(audience: String!, email: String!, password: String!): AuthenticatedUser!
  logUserInFacebook(audience: String!, facebookToken: String!, postRegistrationOptions: PostRegistrationOptions, referralToken: String, referrer: Referrer, userId: ID): AuthenticatedUser!
  logUserInGoogle(audience: String!, googleToken: String!, postRegistrationOptions: PostRegistrationOptions, referralToken: String, referrer: Referrer, userId: ID): AuthenticatedUser!
  logUserInGoogleHoney(audience: String!, googleToken: String!, postRegistrationOptions: PostRegistrationOptions, referralToken: String, referrer: Referrer): AuthenticatedUser!
  logUserInPayPal(audience: String!, paypalAuthCode: String!, postRegistrationOptions: PostRegistrationOptions, referralToken: String, referrer: Referrer, userId: ID): AuthenticatedUser!
  logUserOut(refreshToken: String!): Boolean!
  refreshUserAccessToken(token: String!, options: RefreshTokenVerificationOptionsInput): String!

  """Register user through Apple"""
  registerUserApple(
    audience: String!
    authorizationCode: String!
    firstName: String
    identityToken: String
    lastName: String
    postRegistrationOptions: PostRegistrationOptions
    referralToken: String
    referrer: Referrer
    userId: ID

    """Where the user registered from. Can be the specific screen, flow, etc."""
    registeredFrom: String
  ): AuthenticatedUser!
  registerUserEmail(
    audience: String!
    email: String!
    password: String!
    userId: ID
    postRegistrationOptions: PostRegistrationOptions
    referralToken: String
    source: String
    referrer: Referrer

    """Where the user registered from. Can be the specific screen, flow, etc."""
    registeredFrom: String
  ): AuthenticatedUser!
  registerUserFacebook(
    audience: String!
    facebookToken: String!
    userId: ID
    postRegistrationOptions: PostRegistrationOptions
    referralToken: String
    source: String
    referrer: Referrer

    """Where the user registered from. Can be the specific screen, flow, etc."""
    registeredFrom: String
  ): AuthenticatedUser!
  registerUserGoogle(
    audience: String!
    googleToken: String!
    userId: ID
    postRegistrationOptions: PostRegistrationOptions
    referralToken: String
    source: String
    referrer: Referrer

    """Where the user registered from. Can be the specific screen, flow, etc."""
    registeredFrom: String
  ): AuthenticatedUser!
  registerUserPayPal(
    audience: String!
    paypalAuthCode: String!
    userId: ID
    postRegistrationOptions: PostRegistrationOptions
    referralToken: String
    source: String
    referrer: Referrer

    """Where the user registered from. Can be the specific screen, flow, etc."""
    registeredFrom: String
  ): AuthenticatedUser!
  removeAmbassadorRoleGroup(userId: ID!): Boolean!
  removeUserFromReviewList(userId: ID!, ruleSetId: String!): Boolean!
  resetPassword(email: String!, token: String!, password: String!): Boolean!
  revokeAmbassador(userId: ID!): UserAmbassadorState!
  sendEmailChangeEmail(email: String!): Boolean!
  sendOnboardingOffers(userId: ID!): Boolean!
  sendPasswordResetEmail(email: String!): Boolean!
  sendReferralInvites(userId: ID!, referredEmails: [String!]!, emailBody: String!, referrerName: String, ctaUrl: String, emailSubjectExp: String, urlParams: ReferralInviteUrlParamsInput): [Referral!]!
  setInstallReminderEmail(email: String!): Boolean!
  setUserEmail(userId: ID!, email: String!): Boolean!
  setUserPassword(userId: ID!, password: String!): Boolean!
  setUserPicture(userId: ID!, picture: Upload!): Boolean!
  setUserPictureBase64(userId: ID!, picture: String!): Boolean!
  setUserReferralToken(userId: ID!, newToken: String!): Boolean!

  """
  Sets a user's role groups. Returns true if the operation was successful and throws an error otherwise
  """
  setUserRoleGroups(userId: ID!, roles: [String!]!): Boolean!

  """Unsubscribe an email from a given mailing list"""
  unsubscribeUserByEmailType(email: String!, type: String!, token: String!): Boolean!
  unsubscribeUserEmail(email: String!): Boolean!
  updateEmailSubscriptions(email: String!, subscriptions: Subscriptions!): EmailSubscriptions!
  updatePushNotificationPreferences(userId: ID!, info: PushNotificationPreferencesInput!): User!
  updateRecentSearches(userId: ID!, info: RecentSearchesInput!): User!

  """Update an existing Role Group. Returns the updated role group"""
  updateRoleGroup(groupId: ID!, roleGroupUpdate: RoleGroupUpdateInput!): RoleGroup!
  updateUserFollow(userId: ID!, info: UserFollowInput!): UserFollow!
  updateUserInfo(userId: ID!, info: UserInfoInput!): User!
}

input NewStoresAInput {
  subject: String
  userEmail: String!
  userId: String!
}

input NewStoresBInput {
  subject: String
  userEmail: String!
  userId: String!
}

input NewStoresCInput {
  subject: String
  userEmail: String!
  userId: String!
}

input NewStoresDInput {
  subject: String
  userEmail: String!
  userId: String!
}

input NewStoresEInput {
  subject: String
  userEmail: String!
  userId: String!
}

input NewStoresInput {
  subject: String
  userEmail: String!
  userId: String!
}

"""An object with an ID"""
interface Node {
  """The ID of an object"""
  id: ID!
}

"""types implementing the Template interface"""
type NotificationBasic implements Template {
  templateID: String!
  templateType: TemplateType!
  data: NotificationBasicData!
}

"""types specific to `data` fields on individual templates"""
type NotificationBasicData {
  meta: Meta!
  header: Header
  content: [Content!]
  contentLogo: Image
  button: Button
  actions: Object
}

"""Object"""
scalar Object

"""An Offer Push Notification to be sent to a User"""
type OfferPushNotification {
  """ID of the User this Notification should be sent to"""
  userId: String!

  """Product storeId associated with this Notification"""
  storeId: String!

  """Product parentId associated with this Notification"""
  parentId: String!

  """
  Notification Type used by Honey Mobile to determine message handling (e.g., 'offerOnDroplistedItem')
  """
  notifType: String!

  """Notification Group this belongs to (e.g., 're-engagement')"""
  notifGroup: String!

  """
  Indicates if the Notification was successfully sent to FCM or if it's queued to be sent to FCM
  """
  status: OfferPushNotificationStatus!

  """The time this Notification was created"""
  created: DateTime!

  """The last time this Notification was updated"""
  updated: DateTime!

  """The last time this Notification was queued to be sent to FCM"""
  sendingAt: DateTime

  """The last time this Notification was succesfully sent to FCM"""
  lastSentAt: DateTime
}

"""
Indicates if the Notification is queued to be sent to the external service, or if it failed/succeeded to send to it
"""
enum OfferPushNotificationStatus {
  """Notification failed to send to the external service"""
  FAILED

  """Notification was queued to be sent to the external service"""
  SENDING

  """Notification was successfully sent to the external service"""
  SENT
}

"""Input type for updating an OfferPushNotification"""
input OfferPushNotificationUpdateInput {
  """ID of the User this Notification should be sent to"""
  userId: String!

  """Product storeId associated with this Notification"""
  storeId: String!

  """Product parentId associated with this Notification"""
  parentId: String!

  """
  Notification Type used by Honey Mobile to determine message handling (e.g., 'offerOnDroplistedItem')
  """
  notifType: String!

  """Notification Group this belongs to (e.g., 're-engagement')"""
  notifGroup: String!

  """
  Indicates if the Notification is queued to be sent to FCM, or if it failed/succeeded to send to FCM
  """
  status: String!
}

type OffersCampaign {
  campaignId: ID!
  name: String!
  storeId: String!
  totalBudget: Int
  remainingBudget: Int
  dailyBudget: Int
  state: OffersCampaignState
  updated: Timestamp
  info: OffersCampaignInfo
}

type OffersCampaignInfo {
  salesforce: String
}

input OffersCampaignInfoInput {
  salesforce: String
}

enum OffersCampaignState {
  COMPLETE
  CONTINUE
  ON
  PAUSE
}

"""A notification about Offers"""
type OffersNotification implements Node {
  """The ID of an object"""
  id: ID!

  """ID of the User this Notification should be sent to"""
  userId: String!

  """Notification Group this belongs to (e.g., 're-engagement')"""
  notifGroup: String!

  """The method the user was notified (e.g. push, email)"""
  notifMethod: String!

  """Product storeId associated with this Notification"""
  storeId: String!

  """Product parentId associated with this Notification"""
  parentId: String!

  """
  Notification Type used by Honey Mobile to determine message handling (e.g., 'offerOnDroplistedItem')
  """
  notifType: String!
  status: OfferPushNotificationStatus!

  """The time this Notification was created"""
  created: DateTime!

  """The last time this Notification was updated"""
  updated: DateTime!

  """
  The last time this Notification was queued to the external service (FCM/SendGrid/etc)
  """
  sendingAt: DateTime

  """
  The last time this Notification was successfully sent to the external service  FCM/SendGrid/etc)
  """
  lastSentAt: DateTime
}

"""
Input parameters for updating the status of an OffersNotification object. See field descriptions on that object for details.
"""
input OffersNotificationUpdateInput {
  userId: String!
  notifGroup: String!
  notifMethod: String!
  storeId: String!
  parentId: String!
  notifType: String!
  status: String!
}

type OffersProductGroup {
  campaignId: String!
  groupId: String!
  conversions: Int!
  created: String!
  discountRate: Float!
  groupValue: String!
  groupType: String!
  impressions: Int!
  maximumOfferValue: Int
  updated: String!
}

"""Transaction types used by the Offers system"""
enum OfferTransactionType {
  OFFER
  OFFERS_LEGACY
  OFFER_PRODUCT
  OFFER_PRODUCT_EXT
}

input OnboardingInstallGrowthInput {
  categories: [String!]
  checkUserActionEvent: Boolean
  customEmailType: String
  emailAddress: String!
  url: String!
  userId: String!
  visitorId: String
}

input OnboardingInstallInput {
  categories: [String!]
  emailAddress: String!
  url: String!
  userId: String
  visitorId: String
}

type OnboardingOffers {
  userOnboardingExpires: Timestamp!
  offers: [StoreOffer]
}

input OnboardingOffersInput {
  checkUserActionEvent: Boolean
  emailAddress: String!
  offers: [OnboardingOffersInputOffers!]!
  userId: String!
  visitorId: String
}

input OnboardingOffersInputOffers {
  storeId: String!
  storeName: String!
  value: Float!
}

enum OnboardingStepType {
  DEMO
  FIRST_PURCHASE
  GUEST_FIND_SAVINGS_REGISTRATION
  REGISTRATION
  VIDEO
}

input OnboardingTransactionInput {
  onboardingStep: String!
}

"""
OrderEmail contains information about an email received by the order email relay
"""
type OrderEmail {
  id: ID!
  emailType: String!
  storeId: String!
  storeName: String!
  transactionUUID: String
  userId: String!
  trackingNumber: String
  trackingUrl: String
  receivedAt: Timestamp
  orderId: String
  orderNumber: String
  emailSubject: String
  emailData: Object
  senderAddress: String
  carrier: String
  archived: Boolean
  deliveryStatus: String
  cdnKey: String
  subtype: String
}

"""Fields available for creating an OrderEmail"""
input OrderEmailAddInput {
  emailType: String!
  storeId: String!
  storeName: String!
  transactionUUID: String
  trackingNumber: String
  trackingUrl: String
  receivedAt: Timestamp
  orderId: String
  orderNumber: String
  emailSubject: String
  emailData: Object
  senderAddress: String
  carrier: String
  archived: Boolean
  deliveryStatus: String
  cdnKey: String
  subtype: String
}

input OrderEmailsMeta {
  limit: Int
  lastReceivedAt: Timestamp
}

input OrderEmailsPaginatedQuery {
  emailSubject: String
  orderNumber: String
  storeId: ID
  storeName: String
  transactionUUID: String
  timeRange: Timestamp
  userId: ID
}

input OrderEmailsQuery {
  id: ID
  emailType: String
  storeId: String
  storeName: String
  transactionUUID: String
  trackingNumber: String
  trackingUrl: String
  receivedAt: Timestamp
  orderId: String
  orderNumber: String
  emailSubject: String
  emailData: Object
  senderAddress: String
  carrier: String
  archived: Boolean
  deliveryStatus: String
  cdnKey: String
  subtype: String
}

"""Fields available for updating an OrderEmail"""
input OrderEmailUpdateInput {
  id: ID
  emailType: String
  storeId: String
  storeName: String
  trackingNumber: String
  trackingUrl: String
  receivedAt: Timestamp
  orderId: String
  orderNumber: String
  emailSubject: String
  emailData: Object
  senderAddress: String
  carrier: String
  archived: Boolean
  deliveryStatus: String
  subtype: String
}

"""
OrderPackage contains information about a package associated with an order
"""
type OrderPackage {
  id: ID!
  orderId: ID
  orderNumber: String
  trackingNumber: String
  trackingUrl: String
  lastCheckedAt: Timestamp
  status: String
  carrier: String
  shippoStatus: String
  shippoSubstatus: String
  cartOrderProducts: [CartOrderProduct!]!
}

"""Fields available for creating an OrderPackage"""
input OrderPackageAddInput {
  orderId: ID
  orderNumber: String
  trackingNumber: String
  trackingUrl: String
  lastCheckedAt: Timestamp
  status: String
  carrier: String
  shippoStatus: String
  shippoSubstatus: String
}

"""Fields available for updating an OrderPackage"""
input OrderPackageUpdateInput {
  lastCheckedAt: Timestamp
  trackingUrl: String
  status: String
  carrier: String
  shippoStatus: String
  shippoSubstatus: String
}

"""Query object for requesting a user's orders"""
input OrderQuery {
  """Return only results that have TwoTap errors"""
  hasErrors: Boolean

  """Number of records to return"""
  limit: Int!

  """Offset of the records to return"""
  offset: Int

  """The column to sort by"""
  sortBy: String

  """The sort direction"""
  sortOrder: String

  """
  Additional values to filter the result on. See internal-api-cart/src/orders/operations/read for full list
  """
  filters: Object
}

enum OrderState {
  """Order failed"""
  FAILED

  """Order was fulfilled"""
  LOCKED

  """Order was submitted but not fulfilled yet"""
  PENDING

  """Order failed and linked gifts were unlinked"""
  PURGED
}

type OtherCardBenefit {
  landerTitle: String!
  landerUrl: String!
  benefitType: String
}

type ParentInventory {
  priceRange: PriceRange

  """Honey categories for the parent of the given productId"""
  honeyCategories: [String!]

  """
  The inventory object has dynamic keys, and therefore we cannot use a set schema
  """
  inventory: Object
}

input PartialUserInfoInput {
  firstName: String
  lastName: String
}

input PasswordResetInput {
  categories: [String!]
  emailAddress: String!
  token: String!
  userId: String
}

enum PayoutCurrency {
  """Australian Dollar"""
  AUD

  """Canadian Dollar"""
  CAD

  """Euro"""
  EUR

  """British Pound"""
  GBP

  """US Dollar"""
  USD
}

"""Input field for retrieving stores by currency"""
enum PayoutCurrencyFilter {
  ALL_CURRENCIES
  AUD
  CAD
  EUR
  GBP
  USD
}

"""
A redemption of honey gold, by a gift card or a paypal payment.
Persisted in payoutGifts table.
N PayoutGift-s are related to 1 PayoutOrder, and M payoutGift-s are related to 1 Transaction.
1 PayoutGift is 1:1 with Store and StoreInfo.
"""
type PayoutGift {
  """URL to a barcode of the gift card for INCOMM, null for PAYPAL"""
  barcodeUri: String

  """Code of the gift card for INCOMM, null for PAYPAL"""
  code: String

  """Url to access the gift card for TILLO and INCOMM, null for PAYPAL"""
  codeUrl: String

  """Timestamp of the object creation"""
  created: Timestamp!

  """The value of the gift card in the appropriate currency"""
  currencyAmount: Int!

  """Primary key"""
  payoutGiftId: ID!

  """
  ID of shard where object is stored.
  Currently this is used only as a hash of the primary key.
  """
  payoutGiftShardId: String!

  """Foreign key to payoutOrders"""
  payoutOrderId: String

  """
  INCOMM for gift cards, PAYPAL for USD payments.
  Manually uploaded payouts are now MANUAL, but previously were null.
  """
  payoutProvider: String

  """
  Information about the store the payout gift is for.
  From table payoutStoreInfo, foreign key is payoutStoreInfoShardId (not in GQL type)
  """
  payoutStoreInfo: PayoutStoreInfo

  """
  The trasaction the payoutgift is associated with, from Transactions table.
  Foreign key is payoutTransactionId.
  """
  payoutTransaction: Transaction!

  """
  Foreign key to transactions. Can be null in case a gift card is orderd in advance
  and not as a response to a user request. For PAYPAL, never null.
  """
  payoutTransactionId: ID!

  """Gift card PIN, null for PAYPAL"""
  pin: String

  """State of the gift card"""
  state: PayoutGiftState!

  """
  The store that the gift card was given to, from stores.stores table.
  This is different from payoutStoreInfo in that the payoutStoreInfo has information about gift cards for the store,
  and store has more general information. See also Store type.
  """
  store: Store

  """Foreign key to payoutStoreInfo"""
  storeId: ID!

  """Timestamp of the object last update"""
  updated: Timestamp!

  """Amount of honey gold points for the payout gift"""
  value: Int!
}

"""Fields to be updated in a payout gift when the order is ready."""
input PayoutGiftCardInput {
  externalId: String!
  value: Int!
  code: String
  pin: String
  barcodeUri: String
}

input PayoutGiftCardsInput {
  gifts: [PayoutGiftCardsInputGifts!]!
  userEmail: String!
  userId: String
}

input PayoutGiftCardsInputGifts {
  _empty: String
}

input PayoutGiftCreateInput {
  currencyAmount: Int
  isAvailableInV2: Boolean
  payoutGiftId: ID
  payoutStoreInfoShardId: String
  storeId: ID
  value: Int
}

"""
Input type for creating payout gift.
For specific fields see PayoutGift type.
"""
input PayoutGiftInput {
  barcodeUri: String
  code: String
  pin: String
  state: PayoutGiftState!
  storeId: ID!

  """In honey gold"""
  value: Int!

  """The equivalent of value in currency"""
  currencyAmount: Int!
  payoutStoreInfoShardId: String!
  payoutProvider: String
}

"""
A state that a transaction is found in.
A payout gift that's requested by a user goes through the following states: REQUESTED -> PENDING -> READY -> LOCKED.
At any point any payout gift can be manually marked as FOR_REVIEW (and later returned to its previous state).
Payout gifts that are requested in advance are marked as AVAILABLE, its columns' values will be copied to the
REQUESTED payout gift, and the AVAILABLE row will be deleted.
"""
enum PayoutGiftState {
  """
  Gift card is available to be supplied in response to a future user request.
  """
  AVAILABLE

  """The payout gift requires manual approval."""
  FOR_REVIEW

  """User can use payout gift"""
  LOCKED

  """An order was made, but not finalized yet"""
  PENDING

  """User can be informed about the payout gift"""
  READY

  """The state of a payout gift after a user requested to redeem honey gold"""
  REQUESTED

  """A gift card was voided due to security concerns"""
  VOIDED
}

"""
Input type for updating payout gift.
For specific fields see PayoutGift type.
"""
input PayoutGiftUpdateInput {
  barcodeUri: String
  code: String
  payoutOrderId: String
  payoutProvider: String
  payoutTransactionId: ID
  pin: String
  skipSecurityCheck: Boolean
  state: PayoutGiftState
  value: Int
}

"""
A user request to redeem honey gold, by payment, or one or more payout gifts
1 PayoutOrder is related to N PayoutGifts.
"""
type PayoutOrder implements Node {
  """The ID of an object"""
  id: ID!

  """Primary key"""
  payoutOrderId: ID!

  """INCOMM for gift cards, PAYPAL for USD payments"""
  payoutProvider: String!

  """State of the order"""
  state: String!

  """
  This info is sent to the payout provider when making the order (in the body of the request).
  For INCOMM it has a list of payout gifts with values and stores.
  For PAYPAL it has information about the recepient and the value of the payment.
  """
  orderInfo: String

  """Timestamp of the object creation"""
  created: Timestamp!

  """Timestamp of the object last update"""
  updated: Timestamp!
}

"""
A combination of a payout gift with the order it's associated with.
For specific fields see PayoutGift and PayoutOrder
"""
type PayoutOrderAndGift {
  barcodeUri: String
  code: String
  orderInfo: String
  payoutGift: PayoutGift!
  payoutGiftId: ID!
  payoutOrder: PayoutOrder!
  payoutOrderId: ID!
  payoutProvider: String!
  payoutTransaction: Transaction!
  payoutTransactionId: ID!
  transaction: Transaction! @deprecated(reason: "Please use 'payoutTransaction' instead.")
  pin: String
  storeId: ID!
  value: Int!
}

"""Ties multiple gift IDs together to be linked to an order"""
input PayoutOrderInput {
  giftIds: [ID!]!
  orderInfo: String
}

enum PayoutProviderType {
  """For gift cards"""
  INCOMM

  """For Incomm Australia"""
  INCOMM_AU

  """For Incomm Canada"""
  INCOMM_CA

  """
  For payout gifts that are ordered in advance and not yet associated with a user request
  """
  MANUAL

  """For US dollar payments"""
  PAYPAL

  """For EU gift cards"""
  TILLO
}

"""
A store that a user can request a gift card to. This type contains information related to gift cards from the store.
Persisted in PayoutStoreInfo table.
1 PayoutStoreInfo is related to 1 PayoutGift.
"""
type PayoutStoreInfo implements Node {
  """The ID of an object"""
  id: ID!

  """Identification of the store by INCOMM, or null"""
  externalId: String!

  """
  MANUAL when a person needs to make a manual order.
  There's one row for PAYPAL.
  """
  payoutProvider: PayoutProviderType!

  """
  ID of shard where object is stored
  Currently this is used only as a hash of the primary key.
  """
  payoutStoreInfoShardId: String!

  """
  When false, it's not possible to make a request for a gift card to the store
  """
  active: Boolean!

  """Used by Apollo to filter out rows"""
  hidden: Boolean!

  """Timestamp of the object creation"""
  created: Timestamp!

  """Timestamp of the object last update"""
  updated: Timestamp!

  """Max value allowed to order, in US cents. Deprecated"""
  maxOrderValue: Int @deprecated(reason: "Use 'maxCurrencyAmount' instead.")

  """Min value allowed to order, in US cents. Deprecated"""
  minOrderValue: Int @deprecated(reason: "Use 'minCurrencyAmount' instead.")

  """Max value allowed to order, in currency"""
  minCurrencyAmount: Int!

  """Min value allowed to order, in currency"""
  maxCurrencyAmount: Int!

  """The currency of the payout gifts for the store"""
  currency: PayoutCurrency!

  """Primary key"""
  storeId: ID!

  """Terms of service for the gift card"""
  termsOfService: String

  """Instruction for the user on how to use the gift card"""
  usageInstructions: String

  """Used as an order for the stores"""
  viewPosition: Int!

  """A store object from stores.stores table."""
  store: Store
}

"""
Input type for creating a payout store info.
See PayoutStoreInfo for specific fields
"""
input PayoutStoreInfoCreateInput {
  termsOfService: String
  usageInstructions: String
  storeId: ID!
  active: Boolean!
  hidden: Boolean!
  maxOrderValue: Int
  minOrderValue: Int
  minCurrencyAmount: Int!
  maxCurrencyAmount: Int!
  currency: PayoutCurrency!
  viewPosition: Int!
}

"""
Input type for updating a payout store info.
See PayoutStoreInfo for speicific fields.
"""
input PayoutStoreInfoUpdateInput {
  termsOfService: String
  usageInstructions: String
  storeId: ID
  active: Boolean
  hidden: Boolean
  maxOrderValue: Int
  minOrderValue: Int
  minCurrencyAmount: Int
  maxCurrencyAmount: Int
  currency: PayoutCurrency
  viewPosition: Int
}

type PendingStoreOffer {
  storeId: String!
  storeName: String!
  userId: String!
  campaignId: String!
  created: Timestamp!
  expires: Timestamp!
  offerId: String!
  used: Boolean!
  value: Int!
}

input PostRegistrationOptions {
  visitorId: String!
  countryName: String!
  countryCode: String!
  dontSendEmail: Boolean!
  sendWelcomeReminder: Boolean
  campaign: String
  honeyCampaign: String
  mobile: Boolean
  customEmailType: String
  referrerToken: String
}

type Prediction {
  """prediction value"""
  prediction: String!

  """value determining confidence in prediction"""
  confidence: Float!
}

type PriceHistory {
  history: [Object!]!
  numChanges: Int!

  """ Previous data point before the specified timeframe """
  prevPoint: Object
}

type PriceRange {
  min: Int
  max: Int
}

type Product {
  archived: Boolean
  availability: Boolean
  brand: String
  canonicalUrl: String
  categories: [String!]!
  currency: String
  dealScore: Int
  defaultTags: [String!]
  description: String
  extDescription: String

  """ Whether or not the item is a final sale """
  finalSale: Boolean

  """Honey categories for the parent of the given productId"""
  honeyCategories: [String!]
  imageUrlPrimary: String
  imageUrlPrimaryTransformed(sizes: [String!]): Object
  imageUrlSecondary: [String!]
  isCanonical: Boolean
  isHotDeal: Boolean
  keywords: [String!]!
  offer: ProductOffer

  """ The copy from the merchant displaying the minimum order amount """
  orderMin: String

  """ The minimum order amount required to purchase the item """
  orderMinAmount: Int
  parentId: String!

  """Inventory info for this product's parent"""
  parentInventory: ParentInventory
  policy: String
  priceCurrent: Int!
  productDetails: Object
  priceHistory: PriceHistory
  priceList: Int!
  productId: String!
  productStates: [String!]

  """ The maximum quantity that the user is allowed to add to cart """
  quantityAllowed: Int

  """ The number of units (increment) that the quantity can be changed in """
  quantityIncrement: Int

  """ The quantity that is available (in-stock) for this product """
  quantityInStock: Int

  """ The minimum quantity required to add to cart and make a purchase """
  quantityRequired: Int
  ratingCount: Int
  ratingValue: Float
  related: [RelatedProducts!]
  store: Store!
  storeExtraInfo: Object
  title: String!
  topTag: String
  twotapPurchaseOption: Object
  upc: String
  updated: Timestamp
  variantId: String
  variationInfo: Object
}

"""Debug information stored in BigTable on each Product"""
type ProductDebug {
  productId: String!

  """The full product observation"""
  productObservation: Object!

  """The partial product observation made from only changed fields"""
  productObservationPartial: Object!

  """The raw product observation before processing"""
  productObservationRaw: Object!
}

type ProductDisplay {
  offer: ProductOffer
  priceCurrent: Int!
  priceList: Int!
  productId: String!
  title: String!
}

"""The representation of a group of products"""
type ProductGroup {
  """The title of the product group"""
  groupTitle: String

  """The type of the product group"""
  groupType: ProductGroupType!

  """The group of products"""
  products: [Product!]
}

"""Meta data used to fetch a group of products"""
input ProductGroupMetaInput {
  """The array of product group types required"""
  groupTypes: [ProductGroupType!]!
  limit: Int

  """The source of the query"""
  source: String
}

"""The set of product group types"""
enum ProductGroupType {
  FBT_PRODUCTS
  RECOMMENDED_PRODUCTS
  SIMILAR_PRODUCTS
}

input ProductMetaInput {
  legacyMerchIdV2: String
  legacyVariantIdV2: String
  skipTags: Boolean = true
  storeLabel: String
  shouldGetInventory: Boolean = false
  shouldGetPriceHistory: Boolean = false
  shouldGetRelated: Boolean = false
  shouldGetTags: Boolean = false
}

type ProductOffer {
  offerId: String!
  campaignId: String!
  parentId: String!
  storeId: String!
  offerValue: Int!
  startDate: Timestamp!
  endDate: Timestamp!
  expiration: Timestamp
  numAvailable: Int
  gold: Int
}

"""A user claimed Product Offer Activation"""
type ProductOfferActivation implements Node {
  """The ID of an object"""
  id: ID!
  offerId: ID!
  userId: ID!

  """ISO timestamp of when the user claimed the product offer"""
  activatedAt: DateTime!

  """Bool indicating if user has received gold for their claim"""
  isGoldAwarded: Boolean!

  """Product with an offer that the user has claimed"""
  product: Product

  """Offer claimed by the user"""
  productOffer: ProductOffer!
  storeId: String!
}

type ProductOffersCampaign implements Node {
  """The ID of an object"""
  id: ID!

  """ID of the campaign"""
  campaignId: ID!

  """Name of the campaign"""
  name: String!

  """Id of the store associated with the campaign"""
  storeId: String!

  """Name of the store associated with the campaign"""
  storeName: String!

  """Total budget of the campaign in Honey gold"""
  totalBudget: Int!

  """Remaining budget of the campaign in Honey gold"""
  remainingBudget: Int!

  """Amount of Honey gold the campaign can spend per day"""
  budgetSpendRate: Int

  """Number of credits (in Honey gold) available"""
  creatorCredits: Int

  """Timestamp of campaign creation"""
  created: DateTime!

  """Timestamp of last campaign update"""
  updated: DateTime!

  """Timestamp of when the campaign ends"""
  endDate: DateTime

  """Timestamp of when the campaign begins"""
  startDate: DateTime

  """State of the campaign"""
  state: ProductOffersCampaignState

  """Miscellaneous info associated with the campaign"""
  info: OffersCampaignInfo

  """Templates associated with the campaign"""
  templates: [ProductOffersTemplate!]!
}

enum ProductOffersCampaignState {
  ON
  PAUSED
}

input ProductOffersNewOfferInput {
  emailAddresses: [String!]!
  notification: ProductOffersNewOfferInputNotification!
  product: ProductOffersNewOfferInputProduct!
  productOffer: ProductOffersNewOfferInputProductOffer!
}

input ProductOffersNewOfferInputNotification {
  message: String!
  subject: String!
}

input ProductOffersNewOfferInputProduct {
  imageUrl: String!
  pdpLink: String!
  priceCurrentFormatted: String!
  priceListFormatted: String!
  store: ProductOffersNewOfferInputProductStore!
  title: String!
  variantValues: String
}

input ProductOffersNewOfferInputProductOffer {
  expirationDate: String!
  offerValueString: String!
}

input ProductOffersNewOfferInputProductStore {
  name: String!
}

type ProductOfferStatistics implements Node {
  """The ID of an object"""
  id: ID!
  campaignId: String!
  templateId: String!
  impressions: Int
  conversions: Int
  revenue: Int!
  spend: Int!
}

type ProductOffersTemplate {
  campaignId: ID!
  templateId: ID!
  created: DateTime!
  discountRate: Float!
  maximumOfferValue: Int
  targetingType: String!
  targetingValue: [String]!
  updated: DateTime!

  """Whether the template is currently active"""
  active: Boolean!
  activeOfferCount: Int!
}

"""
There are six variations on this card, differentiated by `productRecommendationType`
"""
type ProductRecommendation implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  productRecommendationType: ProductRecommendationType!
  productId: String!
  product: Product!

  """TODO: will there be a v3 exclusives schema to use?"""
  bonusOffer: TempBonusOffer
}

"""
Covers SimilarItem, PersonalizedDeal, TrendingProduct, PopularProduct, and DailyDroplist variants
all share the same UI, with minor variations in copy. Therefore, there will be a single Card type
and the only difference will be the new field `productRecommendationType`
"""
enum ProductRecommendationType {
  DAILY_DROPLIST
  DROPLIST_PRICEDROP
  PERSONALIZED_PRODUCT_DEAL_RECOMMENDATION
  POPULAR_PRODUCT
  SIMILAR_PRODUCT
  TRENDING_PRODUCT
}

input ProductRelatedMetaInput {
  excludedStoreIds: [String!]
  limit: Int
}

type ProductSecondaryDetails {
  related: [RelatedProducts!]
  defaultTags: [String!]
  priceHistory: PriceHistory
  variations: Object
  group: String
}

input ProductSecondaryMetaInput {
  parentId: String
  priceHistoryFrom: Timestamp
  priceHistoryTimeframe: Int
  relatedLimit: Int
  storeId: String
  tagsLimit: Int
  variantId: String
  source: String
}

input ProductTagsMetaInput {
  limit: Int
}

type Profile {
  categoryPref: [CategoryPreference!]
  brandPref: [BrandPreference!]
  storePref: [StorePreference!]
  reputationScore: [ReputationScore]
}

enum ProviderIdType {
  AF
  AFN
  AL
  APD
  AW
  CF
  CJ
  CN
  COUPONFOLLOW
  DEALSPLUS
  DK
  EBAY
  FLIPKART
  FMTC
  GR
  HOTELSTORM
  IA
  IB
  IR
  LC
  LS
  LSJ
  LT
  OL
  OM
  OND
  PHG
  PJ
  RMN
  RMNM
  SAS
  SC
  SD
  SHIMPLY
  SNAPDEAL
  SZ
  TD
  TT
  VCOMM
  VORCU
  WG
  WX
  ZX
}

input PushNotificationPreferencesInput {
  pushNotificationCart: Boolean
  pushNotificationCheckout: Boolean
  pushNotificationDroplist: Boolean
  pushNotificationOffers: Boolean
  pushNotificationStores: Boolean
  lastCartPushNotification: Timestamp
  lastCheckoutPushNotification: Timestamp
  lastDroplistPushNotification: Timestamp
  lastOffersPushNotification: Timestamp
  lastOrderPushNotification: Timestamp
  lastStoresPushNotification: Timestamp
}

type QualifiedProductArray {
  qualifier: String!
  products: [Product!]!
  title: String!
}

type Query {
  """
  Given an input, retrieves address predictions from Google Places Autocomplete API (cart-proxy)
  """
  getAddressPredictions(input: String!, sessionToken: ID!): AddressPredictions!

  """Get AltOrderNumbers by orderId"""
  getAltOrderNumbers(query: AltOrderNumbersQuery!): [AltOrderNumber!]!
  getCarrierRegexes(carrierNames: [CarrierTypeEnum!]!): [CarrierRegexes!]!

  """
  Fetches a cart without filtering by CartApiSession. Should only be used with internal services.
  """
  getCart(query: CartQuery!): Cart

  """Gets a CartApiSession by either userId or deviceId"""
  getCartApiSession(query: CartApiSessionQueryInput!): CartApiSession
  getCartItemProductIds(limit: Int, offset: Int, modifiedSince: Timestamp): [ID!]!

  """Get CartOrder by honeyOrderId"""
  getCartOrderByHoneyOrderId(userId: ID!, honeyOrderId: ID!): [CartOrder!]!

  """
  Gets the order associated with the honey order id and the guest identifier.
  """
  getCartOrderByHoneyOrderIdGuestUser(guestUserId: ID!, honeyOrderId: ID!): [CartOrder!]!

  """Get CartOrder by orderId"""
  getCartOrderById(userId: ID!, orderId: ID!): CartOrder!

  """
  Gets cart orders for the given guestUserId. This is used during guest find savings.
  """
  getCartOrdersByGuestUserId(guestUserId: ID!, query: CartOrderQueryInput): [CartOrder!]!

  """Get CartOrder by userId"""
  getCartOrdersByUserId(userId: ID!, query: CartOrderQueryInput): [CartOrder!]!

  """Get CartOrders unknown(Orders whose orderNumber is NULL) by userId"""
  getCartOrdersUnknownByUserId(userId: ID!, query: CartOrdersUnknownQueryInput): [CartOrder!]!
  getCartSession(userId: ID!): CartSession!

  """Get CartStoreAccount records"""
  getCartStoreAccounts(query: CartStoreAccountQueryInput!): [CartStoreAccount]
  getCheckoutSupport(conditions: CheckoutSupportQueryParams): [CheckoutSupport!]!
  getCheckoutSupportByStoreId(storeId: ID!): CheckoutSupport!

  """Get a user's single credit card"""
  getCreditCard(userId: ID!, creditCardId: ID!): CreditCard

  """Get a user's credit cards (all)"""
  getCreditCards(userId: ID!): [CreditCard]

  """Get OrderEmail by orderEmailId"""
  getOrderEmailByOrderEmailId(orderEmailId: ID!): OrderEmail!

  """Get OrderEmails by orderNumber"""
  getOrderEmailsByOrderNumber(orderNumber: String!, query: OrderEmailsQuery): [OrderEmail]!

  """Get OrderEmails by storeId, email subject, time range"""
  getOrderEmailsByStoreId(storeId: String!, emailSubject: String, timeRange: TimeRangeType): [OrderEmail]!

  """Get OrderEmail by transactionUUID"""
  getOrderEmailsByTransactionUUID(transactionUUID: String!): [OrderEmail]!

  """Get OrderEmail by email"""
  getOrderEmailsByUserEmail(userEmail: String!, query: OrderEmailsQuery): [OrderEmail]!

  """Get OrderEmail by userId"""
  getOrderEmailsByUserId(userId: ID!, query: OrderEmailsQuery, meta: OrderEmailsMeta): [OrderEmail]!

  """Get OrderEmails by parameters, limited by pagination"""
  getOrderEmailsPaginated(queryParameters: OrderEmailsPaginatedQuery, meta: OrderEmailsMeta!): [OrderEmail]!

  """Get OrderPackage by orderId"""
  getOrderPackagesByCartOrderId(orderId: ID!): [OrderPackage]!

  """Returns the amount of pending checkout gold for user and order"""
  getPendingUserCheckoutOrderGold(
    userId: ID
    deviceId: ID

    """Deprecated: use honeyOrderId instead to exclude pending order(s)"""
    orderId: ID

    """Use to prevent (this) pending order from marking user ineligible"""
    honeyOrderId: ID
  ): Int!

  """
  Given a placeId, returns a 'Honey Address' object from Google Places API (cart-proxy)
  """
  getPlaceDetails(placeId: ID!, sessionToken: ID!): AddressDetails!
  getSenderDomains(query: SenderDomainQueryParams): [SenderDomain!]!

  """
  Returns a shippable address based on the client's postalCode, determined from the ipAddress
  """
  getShippableAddress(userIpAddress: String!): ShippableAddress!

  """Get a *previously* created shippable address by id"""
  getShippableAddressById(addressId: ID!): ShippableAddress!

  """Get a user's single shipping address"""
  getShippingAddress(userId: ID!, shippingAddressId: ID!): ShippingAddress

  """Get a user's shipping addresses (all)"""
  getShippingAddresses(userId: ID!): [ShippingAddress]

  """Get a verified user's address"""
  getVerifiedUserAddress(honeyInputAddress: AddressOnlyInput!): AddressVerification!
  getWalletEmailRegexMasksByStore(storeId: String!): [WalletEmailRegexMask]!
  getWalletEmailRegexes(storeId: String!, category: CategoryTypeEnum!): [WalletEmailRegex]!

  """Returns whether or not the user has pending checkout gold"""
  hasPendingUserCheckoutOrderGold(
    userId: ID!

    """Deprecated: use honeyOrderId instead to exclude pending order(s)"""
    orderId: ID

    """Use to prevent (this) pending order from marking user ineligible"""
    honeyOrderId: ID
  ): Boolean!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node

  """Fetches objects given their IDs"""
  nodes(
    """The IDs of objects"""
    ids: [ID!]!
  ): [Node]!
  version: String!
  getBenefitLander(category: String!, userId: ID, benefitTipId: ID, storeId: ID): BenefitLander!
  getCreditCardOffersForUser(userId: ID, storeId: ID!, filter: String, visitorId: ID): [BenefitTip]
  getCreditCardOffersSummaryByStoreId(storeId: ID!): BenefitTipsSummary!

  """Returns a dash notification given a notification id"""
  getDashNotificationById(notificationId: ID!): DashNotification!

  """Returns an array of dash notifications matching the query"""
  getDashNotifications(dashName: String, onlyActive: Boolean, limit: Int, offset: Int): [DashNotification!]!

  """Returns the dash notification count matching the query"""
  getDashNotificationsCount(dashName: String, onlyActive: Boolean): Int!

  """Gets audits corresponding to an internal short link"""
  getDashboardsAudits(limit: Int, offset: Int, target: String!, type: String!): [DashboardsAudit!]!

  """Retrieves a link by its name"""
  getInternalShortLink(name: String!): InternalShortLink!

  """Gets a list of links"""
  getInternalShortLinks(limit: Int, offset: Int): [InternalShortLink!]!
  getDroplist(userId: ID!, productIds: [String!]!): [Droplist]
  getDroplistByUserId(userId: ID!, meta: DroplistFilterInput): [Droplist]
  getDroplistCollectionsByUserId(userId: ID!): [DroplistCollection!]!
  getDroplistsByParentStoreVariantId(userId: ID!, ids: [DroplistGetInput!]!): [Droplist]
  getTagsByUserId(userId: ID!, meta: DroplistTagsInput): [DroplistTag]

  """Get experiments"""
  getExperiments(active: Boolean, platform: String, archived: Boolean): [Experiment!]!

  """ Example categoryId of the form 'Toys & Games.Sports & Outdoor Play.Yo-yos'
  """
  getCategoriesByCategoryId(categoryId: ID): [String!] @deprecated(reason: "use getCategoriesByCategoryIdV2")
  getCategoriesByCategoryIdV2(categoryId: ID, userId: ID, limit: Int, depth: Int, platform: CollectionPlatform = MOBILE): [Category!]
  getCollection(collectionId: ID!, longTitle: Boolean = true, platform: CollectionPlatform = MOBILE): Collection!
  getCollectionRecipe(collectionRecipeId: ID!): CollectionRecipe!
  getCollectionRecipes(limit: Int, offset: Int): [CollectionRecipe!]!
  getCollectionRecipesQualifiers: [String!]!
  getCollections(collectionRecipeId: ID!, limit: Int, offset: Int, platform: CollectionPlatform = MOBILE): [Collection!]!
  getCollectionsByCategories(categories: [String!]!, offset: Int, limit: Int, productsLimit: Int, seenCollectionIds: [ID!], platform: CollectionPlatform = MOBILE, blockedQualifiers: [String!]): [CollectionPreview!]!
  getCollectionsByUserId(userId: ID, offset: Int, limit: Int, productsLimit: Int, seenCollectionIds: [ID!], platform: CollectionPlatform = MOBILE): [CollectionPreview!]!
  getCollectionsByUserIdForQualifiers(userId: ID, limit: Int, productsLimit: Int, qualifiers: [String!]!, seenCollectionIds: [ID!], platform: CollectionPlatform = MOBILE, offset: Int): [CollectionPreview!]!
  getProductsForCategoriesWithQualifiers(categoryId: ID, limit: Int, platform: CollectionPlatform = MOBILE, qualifiers: [String!]): [QualifiedProductArray!]!
  getStoresByCategoryId(categoryId: ID, limit: Int, platform: CollectionPlatform = MOBILE): [Store!]!
  getStoresByUserId(userId: ID, limit: Int, platform: CollectionPlatform = MOBILE): [Store]!
  getGlobalActivity(brands: [BrandPreferenceInput!], categories: [CategoryPreferenceInput!], stores: [StorePreferenceInput!], createdAfter: Timestamp, eventTypes: [String!], limit: Int, page: Int): GlobalActivityResultSet!

  """
  Retrieves the currently active product offer associated with the given storeId and parentId
  """
  getActiveProductOfferByStoreIdParentId(parentId: String!, storeId: String!): ProductOffer
  getAllStoreIdsWithActiveCampaigns: Object!
  getAvailableStoreOffer(userId: String!, storeId: String!): StoreOffer
  getFullOffersByUserId(userId: ID!): [FullOffer]!

  """
  Fetch the newest product offer associated with the given storeId and parentId
  """
  getLatestProductOffer(parentId: String!, storeId: String!): ProductOffer
  getOfferByOfferId(offerId: String!): StoreOffer
  getPendingOfferByIdAndUserId(offerId: String!, userId: String!): PendingStoreOffer

  """Retrieves a single Product Offer Activation given its keys"""
  getProductOfferActivationById(offerId: String!, userId: String!): ProductOfferActivation

  """Retrieve a users offer activations"""
  getProductOfferActivations(userId: String!, storeId: String!, startDate: DateTime, endDate: DateTime, isGoldAwarded: Boolean, offerExpirationModMS: Int): [ProductOfferActivation!]!

  """Gets a ProductOffer object by its id"""
  getProductOfferById(offerId: ID!): ProductOffer
  getProductOfferTemplateStatistics(campaignId: String!, templateId: String!): ProductOfferStatistics
  getProductOfferTemplates(campaignId: String!): [ProductOffersTemplate]!
  getProductOffersCampaignByCampaignId(campaignId: ID!): ProductOffersCampaign
  getProductOffersCampaigns(limit: Int!, offset: Int): [ProductOffersCampaign]!

  """Get store ids for stores that have active product offers campaigns"""
  getStoreIdsWithActiveProductOffersCampaigns: [String!]!
  getStoreOffersByCampaignId(campaignId: ID!): [StoreOffer]!
  getUserOnboardingOffers(userId: String!, created: Timestamp!, limit: Int, offset: Int): OnboardingOffers!
  searchOffersCampaigns(limit: Int!, offset: Int, campaignId: ID, storeId: String, state: OffersCampaignState): [OffersCampaign]!

  """Returns all the available currencies for payouts"""
  getAllPayoutCurrencies: [PayoutCurrency!]!

  """Get array of currency exchange rate objects"""
  getCurrencyExchangeRates: [CurrencyExchangeRate!]!

  """Returns all failed orders and the payout gifts associated with them"""
  getFailedOrders(limit: Int, offset: Int): [PayoutOrderAndGift]!

  """
  Returns the oldest payout order waiting to be fulfilled.
  Called by a scheduled job to fulfilled payout orders, will be deprecated with payouts API2
  """
  getOldestPendingPayoutOrder(payoutProvider: String): PayoutOrder!

  """Returns a payout gift by its ID"""
  getPayoutGiftByPayoutGiftId(payoutGiftId: ID!): PayoutGift!

  """
  Returns all payout gift associated with a transaction given by an ID.
  Used when locking and notifying a user that a payout request is ready.
  """
  getPayoutGiftsByPayoutTransactionId(payoutTransactionId: ID!): [PayoutGift!]!

  """Returns all payout gift by the store they are give to and their state"""
  getPayoutGiftsCountByStoreIdAndState(storeId: ID!, state: PayoutGiftState!): Int!

  """Returns a payout order by its ID"""
  getPayoutOrderById(payoutOrderId: ID!, payoutProvider: String!): PayoutOrder!

  """Get information for store ID with a payout provider"""
  getPayoutStoreInfo(externalId: ID!, payoutProvider: PayoutProviderType!): PayoutStoreInfo

  """
  Get information for the payout store that fulfills a payout gift with given ID
  """
  getPayoutStoreInfoByPayoutGiftId(payoutGiftId: ID!): PayoutStoreInfo!

  """Returns a payout store by its shard ID"""
  getPayoutStoreInfoByShardId(storeShardId: String!): PayoutStoreInfo!

  """Returns a list of payout stores in a given currency"""
  getPayoutStores(limit: Int, offset: Int, currency: PayoutCurrencyFilter, storeId: ID): [PayoutStoreInfo]

  """
  Returns payout gifts that were requested for a given provider
  Will be deprecated with payouts API2
  """
  getRequestedPayoutGifts(payoutProvider: String, limit: Int, offset: Int): [PayoutGift!]!
  autocomplete(query: String!, count: Int, checkoutStates: [CheckoutStateType!], walletEnabledFilter: Boolean): SearchTrending
  explore(userId: String, meta: ExploreMetaInput): SearchProduct
  getDebugByProductIds(productIds: [String!]!, cellLimit: Int): [ProductDebug!]!
  getInventoryByProductId(productId: String!, inventory: InventoryType): ParentInventory
  getInventoryByStoreIdParentId(storeId: String!, parentId: String!, inventory: InventoryType): ParentInventory
  getProductByIdSecondaryDetails(productId: String!, meta: ProductSecondaryMetaInput, userId: ID): ProductSecondaryDetails
  getProductByIds(productIds: [String!]!, meta: ProductMetaInput): [Product]
  getProductByStoreIdVariantIds(storeId: String!, variantIds: [String!]!, meta: ProductMetaInput): [Product]
  getProductDisplayByIds(productIds: [String!]!): [ProductDisplay]

  """The array of product groups"""
  getProductGroupsById(productId: String!, meta: ProductGroupMetaInput!, userId: ID): [ProductGroup!]!
  getProductPriceHistory(productId: String!, timeframe: Int!, from: Timestamp): PriceHistory
  getProductPriceHistoryByStoreIdVariantId(storeId: String!, variantId: String!, timeframe: Int!, from: Timestamp): PriceHistory
  getProductVariationsByProductId(productId: String!): Object
  getProductVariationsByStoreIdParentId(storeId: String!, parentId: String!): Object
  getRelatedById(productId: String!, meta: ProductRelatedMetaInput): [RelatedProducts]
  getRelatedByStoreIdParentId(storeId: String!, parentId: String!, meta: ProductRelatedMetaInput): [RelatedProducts]
  getStoreWhitelist(limit: Int, offset: Int): [WhitelistedStore!]!
  getTagsById(productId: String!, meta: ProductTagsMetaInput): [String!]
  searchProduct(query: String!, meta: SearchMetaInput): SearchProduct
  storeFront(query: String, meta: StoreFrontMetaInput): SearchProduct
  storeFrontCollection(storeId: String!, meta: StoreCollectionMetaInput): [StoreCollection!]!
  trending(count: Int): SearchTrending
  getPlatforms: [RemoteConfigurationPlatform!]!
  getRemoteConfiguration(platform: String!): RemoteConfiguration
  getRemoteConfigurationKey(platform: String!, key: String!): RemoteConfigurationKey!
  getRemoteConfigurationKeys(platform: String!): [RemoteConfigurationKey]!

  """Get all information of all groups for a user"""
  getAllTestGroupsByUserId(userId: ID!): [UserTestSetting!]!

  """get configurations for all existing tests"""
  getAllTests: [TestSetting]!

  """Retrieve Store Sale Data for Store Based on StoreId Arg"""
  getStoreSaleByStoreId(storeId: ID!): StoreSale!

  """Get stores with sales from a list of storeIds"""
  getStoresWithSalesByIds(storeIds: [ID!]!): [Store!]!

  """Get test configuration by testId"""
  getTestByTestId(testId: ID!): TestSetting!

  """get group information for a user in a test"""
  getTestGroupByUserId(testId: ID!, userId: ID!): UserTestSetting
  search(checkoutStates: [CheckoutStateType!], meta: SearchMetaInput, query: String!, searchType: SearchType!): Search!

  """Get aggregation data from search results"""
  searchAggregations(query: String, meta: SearchMetaInput, aggregations: [AggregationType]): SearchAggregations

  """Get an array of brands by search query"""
  searchBrands(query: String): [SearchBrand!]!

  """Get an array of stores by search query"""
  searchStores(checkoutStates: [CheckoutStateType!], meta: SearchStoresMetaInput, query: String): [Store!]!

  """Get an array of search query types"""
  searchTypes: [String!]!
  searchTypesAndVersions: [SearchTypeAlg!]!

  """Get aggregation data from storefront results"""
  storeAggregations(query: String, meta: StoreFrontMetaInput, aggregations: [AggregationType]): SearchAggregations
  storeSearch(checkoutStates: [CheckoutStateType!], meta: SearchStoresMetaInput, query: String): StoreSearch!
  analyzeQuery(query: String!): AnalyzedQuery!

  """Find active and supported stores"""
  getActiveAndSupportedStores(limit: Int, offset: Int): [Store!]!

  """Find an affiliate link using storeId and affiliateLinkId"""
  getAffiliateLink(storeId: ID!, affiliateLinkId: ID!): StoreAffiliateLink

  """Get all affiliate link objects for a given store"""
  getAffiliateLinks(storeId: ID!): [StoreAffiliateLink!]!

  """Get all distinct Store Partial URLs"""
  getAllPartialURLDomains(limit: Int, offset: Int): [String]!

  """Get all distinct Store Partial URLs"""
  getAllPartialURLs(nocache: Boolean): [Object]!

  """Get all Store Remote Modules"""
  getAllRemoteModules: [StoreRemoteModule]!

  """Get basic store information using storeId"""
  getBasicStoreInfo(storeId: ID!): BasicStoreInfo

  """Get a store changelog entry"""
  getChangelog(storeId: ID!, logId: String!): StoreChangelog

  """Get all changelogs for a given store"""
  getChangelogs(storeId: ID!): [StoreChangelog]!

  """Get change logs by type"""
  getChangelogsByTypes(types: [StoreChangelogType!]!, limit: Int, offset: Int): [StoreChangelog!]!

  """Get private coupons"""
  getCouponsPrivate(
    storeId: ID!
    testGroup: Boolean
    nocache: Boolean

    """
    Deprecated: use limit and offset instead (top is the same as limit=top&offset=0)
    """
    top: Int
    limit: Int
    offset: Int

    """Leave empty to return all states"""
    state: StoreDealStateType
  ): [StoreDeal!]!

  """Get private coupons"""
  getCouponsPublic(storeId: ID!, testGroup: Boolean, top: Int, nocache: Boolean): [StoreDeal!]!

  """Find a StoreDeal using its database ID"""
  getDeal(storeId: ID!, dealId: ID!): StoreDeal

  """Get all StoreDeal objects for a given store by type and code"""
  getDealByTypeAndCode(storeId: ID!, type: StoreDealType!, code: String!, includeHiddenAndFilterInfo: Boolean): StoreDeal!

  """Find a StoreDealExclusion using its store and type"""
  getDealExclusion(storeId: ID!, sourceType: StoreDealSourceType!): StoreDealExclusion

  """Get all StoreDealExclusion objects for a given store"""
  getDealExclusions(storeId: ID!, nocache: Boolean): [StoreDealExclusion!]!

  """Find a StoreDealSource using its store, deal Id and source type"""
  getDealSource(storeId: ID!, dealId: ID!, type: StoreDealSourceType!): StoreDealSource

  """Find all deal sources for a given store and deal"""
  getDealSources(storeId: ID!, dealId: ID!): [StoreDealSource]!

  """Find all deal sources for a given user"""
  getDealSourcesByUserId(userId: ID!, limit: Int, offset: Int): [StoreDealSource!]!

  """Get all deal tags for a given store deal"""
  getDealTags(storeId: ID!, dealId: ID!): [String!]!

  """Get all StoreDeal objects for a given store"""
  getDeals(storeId: ID!, nocache: Boolean): [StoreDeal]!

  """Get all StoreDeal objects for a given store by type"""
  getDealsByType(storeId: ID!, type: StoreDealType!, nocache: Boolean): [StoreDeal]!

  """Get Chrome Store extension stats"""
  getExtensionStats(extensionId: String!): ExtensionStats!

  """Find an External Id using store Id and external Id type"""
  getExternalId(storeId: ID!, type: StoreExternalIdType!): StoreExternalId

  """Get all StoreExternalId objects for a given store"""
  getExternalIds(storeId: ID!, nocache: Boolean): [StoreExternalId]!

  """Get all StoreExternalId objects with a given type"""
  getExternalIdsByType(type: StoreExternalIdType!, limit: Int, offset: Int): [StoreExternalId!]!

  """Get all StoreExternalId objects for a given externalId & type"""
  getExternalIdsByTypeAndId(type: StoreExternalIdType!, externalId: ID!, limit: Int, offset: Int): [StoreExternalId]!

  """Find indexed and supported stores"""
  getIndexedAndSupportedStores(limit: Int, offset: Int): [Store!]!

  """Get random stores not including the one provided"""
  getOtherStores(label: String!): [Store!]!

  """Find a Partial URL using store Id and URL"""
  getPartialURL(storeId: ID!, url: String!): StorePartialURL

  """Get all StorePartialURL objects for a given store"""
  getPartialURLs(storeId: ID!, nocache: Boolean): [StorePartialURL]!

  """Get all StorePartialURL objects for a given domain"""
  getPartialURLsByDomain(domain: String!): [StorePartialURL]!

  """
  Get a map of known domains to partialURLs for that domain, along with storeId and if the store is supported
  """
  getPartialURLsDomainMap(nocache: Boolean): Object!

  """Get the version of the partialURLs cache"""
  getPartialURLsVersion: String!

  """Find popular stores"""
  getPopularStores(limit: Int, offset: Int): [Store!]!
  getProviderIdTypes: [ProviderIdType!]!

  """Get number of available public coupons for store"""
  getPublicCouponCount(storeId: ID!, hidden: Boolean): Int!

  """Get number of available public sales for store"""
  getPublicSaleCount(storeId: ID!): Int!

  """Get all public UGC objects for a given store"""
  getPublicUGCs(storeId: ID!, limit: Int, offset: Int, nocache: Boolean): [UserGeneratedCoupon]!

  """Find random stores"""
  getRandomStores: [Store!]!

  """Get coupons that were recently applied successfully for a country"""
  getRecentlyAppliedCountryCoupons(country: String!): [StoreDeal!]!

  """Get coupons that were recently applied successfully across all stores"""
  getRecentlyAppliedCouponsAllStores: [StoreDeal!]!

  """Get coupons that were recently applied successfully for a store"""
  getRecentlyAppliedStoreCoupons(storeId: ID!): [StoreDeal!]!

  """Find related stores"""
  getRelatedStores(label: String!): [RelatedStore!]!

  """Find a remote module using store Id and module type"""
  getRemoteModule(storeId: ID!, type: String!): StoreRemoteModule

  """Get all StoreRemoteModule objects for a given store"""
  getRemoteModules(storeId: ID!): [StoreRemoteModule]!

  """Get private sales"""
  getSalesPrivate(
    storeId: ID!
    testGroup: Boolean
    nocache: Boolean

    """
    Deprecated: use limit and offset instead (top is the same as limit=top&offset=0)
    """
    top: Int
    limit: Int
    offset: Int

    """Leave empty to return all states"""
    state: StoreDealStateType
  ): [StoreDeal!]!

  """Get public sales"""
  getSalesPublic(storeId: ID!, testGroup: Boolean, top: Int, nocache: Boolean): [StoreDeal!]!

  """Find a store scrape using store Id and scrape type"""
  getScrape(storeId: ID!, scrapeType: String!): StoreScrape

  """Get all StoreScrape objects for a given store"""
  getScrapes(storeId: ID!): [StoreScrape]!

  """Get a specific section"""
  getSectionBySectionId(sectionId: ID!): StoreSection!

  """Get the shipping info for a store"""
  getShippingInfoByStoreId(storeId: ID!): ShippingInfo!

  """Get a shipping restriction for a store"""
  getShippingRestriction(storeId: ID!, shippingRestrictionId: ID!): ShippingRestrictionType!

  """Get all shipping restrictions for a store"""
  getShippingRestrictionsForStore(storeId: ID!): [ShippingRestrictionType]!

  """Get a paginated set of deals ranked by their `position` field"""
  getSortedDealsPublic(storeId: ID!, limit: Int, offset: Int): [StoreDeal!]!

  """Find a Store using its database ID"""
  getStoreById(storeId: ID!, nocache: Boolean): Store

  """Find a Store using its label"""
  getStoreByLabel(label: String!, nocache: Boolean): Store
  getStoreChangelogTypes: [StoreChangelogType!]!

  """Get a stores internationalization group information"""
  getStoreInternationalizationGroup(storeId: ID!): StoreInternationalizationGroup

  """Get a list of store scrapes by scrape type"""
  getStoreScrapesByType(scrapeType: String!, limit: Int, offset: Int): [StoreScrape]!

  """Get all of a stores sections"""
  getStoreSections(storeId: ID!): [StoreSection!]!

  """Get all of a stores sections by type (ex: all tips or all sections)"""
  getStoreSectionsByStoreIdAndType(storeId: ID!, sectionType: String!): [StoreSection!]!

  """Get a store tag for a given store"""
  getStoreTag(storeId: ID!, storeTag: String!, storeTagType: String!): StoreTag!

  """Get all store tags for a given store"""
  getStoreTags(storeId: ID!, limit: Int, offset: Int): [StoreTag!]!

  """Get all stores"""
  getStores(limit: Int, offset: Int): [Store!]!

  """Get stores by checkout states"""
  getStoresByCheckoutStates(checkoutStates: [CheckoutStateType!]!, limit: Int, offset: Int): [Store!]!

  """Find stores by countries and providerIds"""
  getStoresByCountriesAndProviderIds(countries: [String!]!, providerIds: [String!]!, limit: Int, offset: Int): [Store!]!

  """Get stores from a list of storeIds"""
  getStoresByIds(storeIds: [ID!]!): [Store!]!

  """Find stores where name is prefixed with the passed in string"""
  getStoresByNamePrefix(namePrefix: String!, limit: Int, offset: Int, nocache: Boolean, privateSearch: Boolean): [Store!]!

  """Find stores by sources their deals exclude"""
  getStoresByStoreDealExclusion(excludedSourceType: StoreDealSourceType!, limit: Int, offset: Int): [Store!]!

  """Get stores by URL"""
  getStoresByURL(url: String!): [Store!]!

  """Find stores created within timerange"""
  getStoresCreatedWithinTimeRange(createdBefore: Timestamp, createdAfter: Timestamp, limit: Int, offset: Int): [Store!]!

  """Find stores having product data"""
  getStoresWithActiveProductData: [Store]!

  """Find stores with affiliate"""
  getStoresWithAffiliate(limit: Int, offset: Int): [Store!]!

  """Find stores having product data"""
  getStoresWithCartEnabled(limit: Int, offset: Int): [Store]!

  """Get all stores with on the product fetcher whitelist"""
  getStoresWithProductFetchers(limit: Int, offset: Int): [Store]!

  """Find top stores based on score"""
  getTopStores(limit: Int, offset: Int, country: String): [Store!]!

  """Find a UGC by store Id and code"""
  getUGC(storeId: ID!, code: String!): UserGeneratedCoupon

  """Get all UGC objects for a given store"""
  getUGCs(storeId: ID!, limit: Int, offset: Int, nocache: Boolean): [UserGeneratedCoupon]!

  """Retrieve all UGCs where given userId is found in sourceUserIds"""
  getUGCsByUserId(userId: ID!, limit: Int, offset: Int): [UserGeneratedCoupon!]!

  """Attempt to match a full URL to its corresponding store"""
  matchingStoreForUrl(url: String!): Store!
  getAffiliateProviderIdTypes: [AffiliateProviderIdType!]!
  getAllActiveStoresCashbackOffers(activeDuring: Timestamp, isActive: Boolean, limit: Int, offset: Int): [StoresCashbackOfferResponse!]!

  """
  Returns a list of AnomalousTransactionLog records in the given options.
  onlyLatestLog: returns the latest log for each transaction if this is True, otherwise returns all logs.
  operationType: the filter for operationType.
  """
  getAnomalousTransactionLogs(onlyLatestLog: Boolean!, operationType: String, createdAfter: DateTime, limit: Int!, offset: Int!): [AnomalousTransactionLog!]!
  getCashbackSettings: CashbackSettingsResponse!
  getCashbackStats(limit: Int, offset: Int): [CashbackStatsResponse!]!
  getCashbackStatsById(storeId: ID!): CashbackStatsResponse!
  getCommissionRateByIdOverInterval(storeId: ID!, intervalDays: Int!): CommissionRateResponse!
  getReferralStats(userId: ID!): ReferralStats
  getStoresCashbackOffers(storeId: ID!, activeDuring: Timestamp, limit: Int, offset: Int, nocache: Boolean): [StoresCashbackOfferResponse!]!
  getTransactionById(transactionId: ID!): Transaction
  getTransactionsByStateAndType(state: TransactionState!, type: TransactionType!, limit: Int, offset: Int, createdAfter: Timestamp): [Transaction!]!
  getTransactionsByUserId(userId: ID!, transactionId: ID, type: TransactionType, state: TransactionState, start: Timestamp, end: Timestamp, visible: Boolean, filterMobile: Boolean, limit: Int, offset: Int): [Transaction!]!
  getUniqueStoresCashbackOffer(storeId: ID!, started: Timestamp!): StoresCashbackOfferResponse!
  getUsersPointsByUserId(userId: ID!): UsersPoints!
  searchTransactionStats(type: TransactionType!, start: Timestamp, end: Timestamp, limit: Int, offset: Int, storeId: [ID!], groupByStore: Boolean): [AffiliateCashbackStatsResponse!]!

  """Get a list of user profile entries by user id."""
  getUserProfileById(userId: ID!, types: [String!]!): [UserProfileEntry!]!
  getCards(userId: String, lastCardId: String, direction: String, platform: Int, limit: Int): [Card]
  getCardsStatus(userId: String!, since: Int!, platform: Int, limit: Int): Int
  getTemplates(userId: String, lastCardId: String, direction: String, platform: Int, limit: Int): [Template]
  getTemplatesStatus(userId: String!, since: Int!, platform: Int, limit: Int): Int
  getTemplatesStatusWithRetry(userId: String!, since: Int!, platform: Int): StatusWithRetry
  getAllUserRoleGroups: [RoleGroup!]!

  """ambassador applications"""
  getAmbassadorApplicationEvents(limit: Int, offset: Int): [AmbassadorApplicationEvent!]!
  getAmbassadorApplications(state: AmbassadorApplicationState, limit: Int, offset: Int): [UserAmbassadorState!]!
  getAuthPublicKeys: AuthPublicKeys!
  getEmailSubscriptions(email: String!): EmailUnsubscribes
  getMobileWaitlistByUserId(userId: ID!): MobileWaitlist! @deprecated(reason: "This will only be used for the staged release of the mobile app")
  getProfileById(userId: ID!): Profile! @deprecated(reason: "Use `getUserProfileEntriesById` instead")
  getReferralByReferredId(referredId: ID!): Referral
  getReferralsById(limit: Int, offset: Int, userId: ID!): [Referral]
  getUserAmbassadorApplication(userId: ID!): UserAmbassadorState!
  getUserAmbassadorApplicationEvents(userId: ID!, limit: Int, offset: Int): [AmbassadorApplicationEvent!]!
  getUserByEmail(email: String!): User
  getUserById(userId: ID!): User
  getUserByIdWithVersionCheck(userId: ID!, version: String!): UserWithVersionCheck!
  getUserByReferralToken(referralToken: String!): User
  getUserDashboards(userId: ID!): [String!]!
  getUserDeletion(userId: ID!): UserDeletion!
  getUserFollow(userId: ID!, type: UserFollowType!): UserFollow
  getUserNotesById(userId: ID!): [UserNote]
  getUserProfileEntriesById(userId: ID!, types: [String!]!): [UserProfileEntry!]! @deprecated(reason: "Use `getUserProfileById` instead")
  getUserReviewList(limit: Int, offset: Int, ruleSetId: String): [UserInReview!]!

  """Get followed stores by a userId"""
  getUserStoreFollow(userId: ID!): [Store!]!
  isEmailSubscribed(email: String!, subscription: String!): Boolean!
  isUserInReviewListByRuleSet(userId: ID!, ruleSetId: String!): Boolean!
  verifyUserAccessToken(token: String!, options: AccessTokenVerificationOptionsInput): Boolean!
  verifyUserRefreshToken(token: String!, options: RefreshTokenVerificationOptionsInput): Boolean!

  """The currently authenticated user"""
  viewer: User
}

input RecentSearchesInput {
  recentSearches: String
}

type RecommendationBasic implements Template {
  templateID: String!
  templateType: TemplateType!
  data: RecommendationBasicData!
}

type RecommendationBasicData {
  meta: Meta!
  header: Header
  image: Image
  heroImage: Image
  title: ActionText
  button: Button
  content: [Content!]
  footer: Footer
  actions: Object
}

type RecommendationColumn implements Template {
  templateID: String!
  templateType: TemplateType!
  data: RecommendationColumnData!
}

type RecommendationColumnData {
  meta: Meta!
  header: Header
  description: [Content!]
  items: [RowItem!]!
  icon: Icon
  image: Image
  footerLeft: Footer
  footerRight: Footer
  footerCenter: Footer
  actions: Object
  options: Object
}

type Referral {
  userId: ID!
  referralId: String!
  created: Timestamp!
  referredEmail: String!
  referredId: ID
}

type ReferralConfirmed implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  userId: ID!

  """get `email` from User"""
  user: User!
}

input ReferralInviteInput {
  body: String!
  ctaUrl: String
  emailAddress: String!
  referralId: String
  referralToken: String!
  subject: String
  userId: String!
}

input ReferralInviteUrlParamsInput {
  sweepstakes: String
}

"""TODO: write resolvers"""
type ReferralPending implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  userIds: [ID]!

  """
  get user[0]'s `email` field
  reason: the copy either looks like
    * boba@joinhoney.com signed up but hasn't made a purchase
    * 4 friends signed up but haven't made a purchase
  """
  firstUser: User!
}

type ReferralStats {
  userId: ID!
  numPending: Int!
  numLocked: Int!
  totalValuePending: Int!
  totalValueLocked: Int!
}

input ReferralTransactionInput {
  userId: ID!
  referralReferredUserId: ID!
  referralLinkedTransactionId: ID!
}

input Referrer {
  referralToken: String!
  id: ID!
}

input RefreshTokenVerificationOptionsInput {
  userId: ID
  audience: String
}

type RelatedProducts {
  imageUrlPrimary: String
  imageUrlPrimaryTransformed: Object
  priceCurrent: Int!
  priceList: Int!
  productId: String!
  title: String!
}

type RelatedStore {
  label: String!
  name: String!
}

type RemoteConfiguration {
  platform: String!
  keys: RemoteConfigurationFields @deprecated(reason: "Deprecated. Use fields instead.")
  fields: JSON!
}

type RemoteConfigurationFields {
  enabledStoresCount: Int!
  findSavingsEnabled: Boolean!
  isInviteModeEnabled: Boolean!
  pfAllowedStalenessMinutes: Int!
  honeyGoldDollarTransactionLimit: Int!
  guestCheckoutNoFindSavingsDefaultOfferHoneyGold: Int!
  userAgent: JSON!
  isColorsFilterEnabled: Boolean!
  isDroplistCollectionsGlobalSaveEnabled: Boolean!
  isDroplistCollectionsModalEnabled: Boolean!
  isDroplistSearchEnabled: Boolean!
  isExtensionExplainerEnabled: Boolean!
  droplistCollectionsModalHasDefault: Boolean!
  isOffersFilterEnabled: Boolean!
  isHotDealsEnabled: Boolean!
  isGuestFindSavingsFlowEnabled: Boolean!
  isStrongPasswordAuthEnabled: Boolean!
  isStoreFrontShopByCategoryEnabled: Boolean!
  shouldDisplaySearchSpellCorrections: Boolean!
  savingsAppRatingPromptEnabled: Boolean!
  isPaypalAuthEnabled: Boolean!
  isPDPShareEnabled: Boolean!
  isNativeHoneyGoldEnabled: Boolean!
  apiHostDataApiBaseUrl: URL!
  apiHostGooglePlacesBaseUrl: URL!
  apiHostProductObservationUrl: URL!
  apiHostSdataUrl: URL!
  apiHostStoreVimsUrl: URL!
  apiHostTwoTapWebhookBaseUrlProduction: URL!
  apiHostTwoTapWebhookBaseUrlStaging: URL!
  minimumRunnableVersion: String!
  exploreCollectionsTTL: String!
  exploreCategoriesTTL: String!
  exploreStoresTTL: String!
  collectionProductsTTL: String!
  categoryProductsTTL: String!
  categoryStoresTTL: String!
  categoryCollectionsTTL: String!
  categorySubcategoriesTTL: String!
  paypalAuthUrl: String!
  productCatalogFreshnessSLA: Int!
  imageServiceRollout: Int!
  exploreShopByCategoryTestProbability: Int!
  paginationTestRollout: Int!
}

type RemoteConfigurationKey {
  platform: String!
  key: String!
  value: String!
  type: RemoteConfigurationType!
  description: String
  created: Timestamp!
  updated: Timestamp!
  id: ID!
}

input RemoteConfigurationKeyInsertInput {
  platform: String!
  key: String!
  value: String!
  type: RemoteConfigurationType!
  description: String
}

input RemoteConfigurationKeyUpdateInput {
  value: String!
  description: String
}

type RemoteConfigurationPlatform {
  name: String!
  created: Timestamp!
  updated: Timestamp!
}

type RemoteConfigurationSuccess {
  success: Boolean
}

enum RemoteConfigurationType {
  BOOLEAN
  FLOAT
  INT
  JSON
  STRING
}

type ReputationScore {
  score: Float!
  version: String!
}

type Response {
  status: Boolean!
  data: TestSetting
}

input ResurrectionCampaignInput {
  emailType: String!
  users: [ResurrectionCampaignInputUsers!]!
}

input ResurrectionCampaignInputUsers {
  userEmail: String!
  userId: String!
}

input RewardsBonusPendingInput {
  purchaseTimeStamp: Float!
  rawEmailAddress: String!
  rawFlatReward: Float
  rawOrderTotalForRewards: Float!
  rawRewardsRate: Float!
  rawToken: String!
  storeId: String!
  storeIsFlatFee: Boolean
  storeName: String!
  userId: String
}

"""Describes a role group type"""
type RoleGroup {
  """
  Unique identifier for a role group. Should be a lower-case-kebab string
  """
  groupId: ID!

  """Role group description. Max length 512 characters"""
  description: String!

  """
  An array of unique roles that are covered under the role group. All roles should be lower-case-kebab strings
  """
  roles: [String!]!
}

"""Describes input for updating a role group"""
input RoleGroupUpdateInput {
  """
  Optional description update for a role group. Max length 512 characters
  """
  description: String

  """
  Optional roles update for a role group. All roles should be lower-case-kebab strings
  """
  roles: [String!]
}

type RowItem {
  title: ActionText
  icon: Icon
  logo: Image
  content: [Content!]
  button: Button
}

input SafariExtensionUpdateTriggerInput {
  customEmailType: String
  subject: String
  userEmail: String!
  userId: String!
}

input SafariOsUpdateTriggerInput {
  subject: String
  userEmail: String!
  userId: String!
}

type Search {
  """Get an array of exact match brands by search query"""
  brands: [SearchBrand!]

  """Get an array of stores by search query"""
  stores: [Store!]

  """Get an array of products by search query"""
  products: SearchProduct
}

type SearchAggregations {
  brands: [String!]
  categories: SearchCategories
  stores: [Store!]
  tags: [String!]
}

type SearchBrand {
  name: String!
}

type SearchCategories {
  categories: [String!]!
  path: String!
}

input SearchMetaInput {
  algo: String
  availability: Boolean
  brands: String
  categories: String
  limit: Int
  maxPrice: Int
  minPrice: Int
  offersOnly: Boolean
  hotDealsOnly: Boolean
  offset: Int
  colors: String
  sizes: String
  sort: String
  storeIds: String
  tags: String
  userId: ID
  walletEnabledFilter: Boolean
  explain: Boolean
}

type SearchProduct {
  meta: SearchProductMeta
  products: [Product!]

  """Explanation for how search API handles this specific query"""
  explanation(query: String!, meta: SearchMetaInput): String
}

type SearchProductItem {
  availability: Boolean
  brand: String
  currency: String
  imageUrlPrimary: String
  imageUrlPrimaryTransformed: Object
  isHotDeal: Boolean
  offer: ProductOffer
  parentId: String!
  priceCurrent: Int!
  priceList: Int!
  productId: String!
  score: Int
  store: Store!
  title: String!
  topTag: String!
  variationInfo: Object
}

type SearchProductMeta {
  spellCorrectedQuery: String
  brands: [String!]
  colors: [String!]
  categories: [String!] @deprecated(reason: "Use `suggestedCategories` instead.")
  limit: String
  offset: String
  related: [String!]
  sizeMenu: [SearchProductSizeOptions]!
  stores: [Store!]
  suggestedCategories: SearchCategories
  tags: [String!]
  total: String
  group: String
}

type SearchProductSizeOptions {
  children: [SearchProductSizeOptions!]
  label: String!
}

type SearchStore {
  checkoutState: CheckoutStateType!
  label: String!
  name: String!
  storeId: ID!
}

input SearchStoresMetaInput {
  limit: Int
  offset: Int

  """Field to sort stores result by"""
  sort: SearchStoresSort
}

enum SearchStoresSort {
  SHOPPERS_24H
  SHOPPERS_30D
  STORE_NAME
}

type SearchTrending {
  products: [String!]
  stores: [Store!]
  tags: [String!]
}

enum SearchType {
  ALL
  BRANDS
  PRODUCTS
  STORES
}

"""Search type algorithm and list of its applicable versions"""
type SearchTypeAlg {
  searchType: String!
  versions: [String!]!
}

type SearchTypeOverride {
  successful: Boolean!
  error: String
}

"""senderDomain contains info about whether a domain is whitelisted"""
type SenderDomain {
  """Store ID"""
  storeId: String!

  """Email domain"""
  domain: String!

  """Whether domain is currently active"""
  isActive: Boolean!
}

input SenderDomainQueryParams {
  """Store ID"""
  storeId: String

  """Email domain"""
  domain: String

  """Whether domain is currently active"""
  isActive: Boolean
}

type ShippableAddress implements Node {
  """The ID of an object"""
  id: ID!

  """A UUID for this address object"""
  addressId: ID!
  address: Address!
}

type ShippingAddress implements Node {
  """The ID of an object"""
  id: ID!
  userId: ID!
  shippingAddressId: String!
  isDefault: Boolean!
  shippingAddressSnapshot: ShippingAddressSnapshot!
}

input ShippingAddressAddInput {
  isDefault: Boolean!
  address: AddressInput!
}

type ShippingAddressSnapshot implements Node {
  """The ID of an object"""
  id: ID!
  userId: ID!
  shippingAddressSnapshotId: ID!

  """
  The shipping address ID of the shipping address that originally pointed to
  this snapshot. It may or may not be pointing to it now
  """
  shippingAddressId: ID!
  address: Address!
}

input ShippingAddressUpdateInput {
  isDefault: Boolean
  address: AddressUpdateInput
}

"""Shipping Estimates from TwoTap"""
type ShippingEstimates {
  """The 4 in '4-6 days'"""
  minDeliveryDays: Int

  """The 6 in '4-6 days'"""
  maxDeliveryDays: Int
}

"""Input for Shipping Estimates from TwoTap"""
input ShippingEstimatesInput {
  """The 4 in '4-6 days'"""
  minDeliveryDays: Int

  """The 6 in '4-6 days'"""
  maxDeliveryDays: Int
}

type ShippingInfo implements Node {
  """The ID of an object"""
  id: ID!
  freeShippingThreshold: Int
}

input ShippingInfoInput {
  freeShippingThreshold: Int
}

input ShippingRestrictionInput {
  attribute: String
  description: String
  ruleName: String
  value: String
}

type ShippingRestrictionType implements Node {
  """The ID of an object"""
  id: ID!
  attribute: String
  description: String!
  ruleName: String!
  shippingRestrictionId: ID!
  value: String
}

enum ShippingSpeed {
  CHEAPEST
  FASTEST
  FS_CHEAPEST
  FS_FASTEST
}

"""Response from a startCheckout operation"""
type StartCheckoutResponse {
  """The updated cart after checkout was started"""
  cart: Cart

  """The timestamp of when checkout was started"""
  checkoutStartedAt: Timestamp

  """The total offer value persisted when checkout was started"""
  totalOfferValue: Int

  """Any errors returned when initiating the startCheckout operation"""
  errors: [CheckoutError!]
}

type StatusWithRetry {
  status: Int!
  retry: Int
}

type Store implements Node {
  """The ID of an object"""
  id: ID!
  storeId: ID!
  active: Boolean!
  affiliateRestrictions: String
  affiliate: AffiliateTagInfo
  affiliateURL: String
  oldAffiliateURL: String
  affiliateTagTypes: [StoreTagType!]
  affiliateLinks: [StoreAffiliateLink!]!
  avgSavings24h: Int
  avgSavings30d: Int
  avgSavingsChange: Int
  checked: Timestamp
  country: String!
  coupons(nocache: Boolean): [StoreDeal]!
  created: Timestamp!
  deals(nocache: Boolean): [StoreDeal!]!
  privateCoupons(nocache: Boolean): [StoreDeal!]!
  publicCoupons(nocache: Boolean, limit: Int, offset: Int, top: Int): [StoreDeal!]!
  privateSales(nocache: Boolean): [StoreDeal!]!
  publicSales(nocache: Boolean, limit: Int, offset: Int, top: Int): [StoreDeal!]!
  publicSortedDeals(limit: Int): [StoreDeal!]!
  externalIds(nocache: Boolean): [StoreExternalId!]!
  freeShippingThreshold: Int
  privateCouponCount: Int
  publicCouponCount(hidden: Boolean): Int
  privateSaleCount: Int
  publicSaleCount: Int!
  forceJsRedirect: Boolean!
  hasCartSupport: Boolean!
  hasIcon: Boolean!
  hasProductData: Boolean!
  indexShopPage: Boolean
  label: String!
  metadata: String
  name: String!
  notesMonetization: String
  notesSupport: String
  notesWorker: String
  numSavings24h: Int
  numSavings30d: Int
  numSavingsChange: Int
  partialUrls(nocache: Boolean): [StorePartialURL!]!
  position: Int
  productRegex: [String]
  providerId: ID
  oldProviderId: ID
  sales(nocache: Boolean): [StoreDeal]!
  score: Int
  sections: [StoreSection!]!
  shoppers24h: Int
  shoppers30d: Int
  shoppersChange: Int
  supported: Boolean!
  supportStage: StoreSupportStageType!
  updated: Timestamp!
  userCoupons(nocache: Boolean): [UserGeneratedCoupon]!
  publicUserCoupons(nocache: Boolean, limit: Int, offset: Int): [UserGeneratedCoupon]!
  url: String!
  returnInfo: String
  returnRequiresLogin: Boolean
  supportEmail: String
  supportPhoneNumber: String
  supportUrl: String
  tosUrl: String
  supportHours: String
  returnInitUrl: String
  currentCashbackOffer: StoresCashbackOfferResponse
  previousCashbackOffer: StoresCashbackOfferResponse
  storeDealExclusions: [StoreDealExclusion!]!
  storeInternationalizationGroup: StoreInternationalizationGroup
  storeLinks: [StoreLink!]!
  isUGCEnabled: Boolean!
  checkoutState: CheckoutStateType
  storeSale: StoreSale
}

type StoreAffiliateLink implements Node {
  """The ID of an object"""
  id: ID!
  storeId: ID!
  affiliateLinkId: ID!
  affiliateURL: String!
  category: String
  created: Timestamp!
  deeplink: Boolean!
  expiration: Timestamp
  networkReferenceId: String
  note: String
  providerId: String!
  removed: Timestamp
  updated: Timestamp!
  weight: Int!
}

input StoreAffiliateLinkInput {
  affiliateURL: String!
  category: String
  deeplink: Boolean!
  expiration: Timestamp
  networkReferenceId: String
  note: String
  providerId: String!
  weight: Int!
}

type StoreChangelog implements Node {
  """The ID of an object"""
  id: ID!
  logId: ID!
  store: Store!
  storeId: ID!
  type: StoreChangelogType!
  author: String!
  note: String!
  created: Timestamp!
}

input StoreChangelogCreateInput {
  logId: ID
  type: StoreChangelogType!
  author: String!
  note: String!
}

enum StoreChangelogType {
  CHECKOUT_STATE_CHANGED
  COMMISSION_DECREASE
  COMMISSION_INCREASE
  DEAL_COUPON
  DEAL_SALE
  EXCLUSIVE_CODE_ACTIVATED
  EXCLUSIVE_CODE_EXPIRED
  FIX_ATTEMPTED
  FULL_REVENUE_SUPPORT
  HONEYGOLD_ACTIVATED
  HONEYGOLD_CREATED
  HONEYGOLD_EXPIRED
  HONEYGOLD_VERIFIED
  NOTE_GENERIC
  NOTE_MONETIZATION
  NOTE_SUPPORT
  SECTION_DELETED
  SECTION_UPSERTED
  STARTED_ORDER_ID_TRACKING
  STORETAG_UPDATE
  STORE_DEACTIVATED
  STORE_HEALTH_ACCURATE_PRICES
  STORE_HEALTH_ALL_CODES_TRIED
  STORE_HEALTH_FIND_SAVINGS_FINISHED
  STORE_HEALTH_HEALTH_SCORE
  STORE_HEALTH_REVENUE_DOLLAR
  STORE_HEALTH_REVENUE_PERCENT
  STORE_HEALTH_SHOWING_AS_EXPECTED
  STORE_PARTNERSHIP_APPROVED
  STORE_REACTIVATED
  SUPPORT_PROBLEM
  UGC_DEACTIVATED
  UGC_REACTIVATED
  VANITY_CODE_ACTIVATED
  VANITY_CODE_EXPIRED
}

"""The representation of a collection of products for a specific store"""
type StoreCollection {
  """The title of the collection"""
  collectionTitle: String!

  """The type of the store collection from `StoreCollectionType`"""
  collectionType: StoreCollectionType!

  """Search metadata"""
  meta: SearchProductMeta

  """Products in the collection"""
  products: [Product!]
}

"""Meta data used by search to filter store collection results"""
input StoreCollectionMetaInput {
  """The list of brand filters as a comma separated string"""
  brands: String

  """The list of category filters as a comma separated string"""
  categories: String

  """The list of store collection types from `StoreCollectionType`"""
  collectionTypes: [StoreCollectionType!]
  limit: Int
  maxPrice: Int
  minPrice: Int
  offset: Int

  """The list of size filters as a comma separated string"""
  sizes: String
  sort: String

  """The list of tag filters as a comma separated string"""
  tags: String
  userId: String
}

"""The set of collection types for a specific store"""
enum StoreCollectionType {
  BEST_DEAL
  NEW_ARRIVAL
  OFFER
  POPULARITY
  RECENT_VIEW
  TRENDING
}

"""Fields available for creation of a store"""
input StoreCreateInput {
  storeId: ID
  active: Boolean
  affiliateRestrictions: String
  affiliateTagTypes: [StoreTagType!]
  affiliateURL: String
  avgSavings24h: Int
  avgSavings30d: Int
  avgSavingsChange: Int
  checked: Timestamp
  country: String!
  forceJsRedirect: Boolean
  hasCartSupport: Boolean
  hasIcon: Boolean
  hasImage: Boolean
  hasTrendingImage: Boolean
  indexShopPage: Boolean
  label: String!
  metadata: String
  name: String!
  notesMonetization: String
  notesSupport: String
  notesWorker: String
  numSavings24h: Int
  numSavings30d: Int
  numSavingsChange: Int
  position: Int
  productRegex: [String]
  providerId: ID
  score: Int
  shoppers24h: Int
  shoppers30d: Int
  shoppersChange: Int
  supported: Boolean
  supportStage: StoreSupportStageType
  url: String!
  returnInfo: String
  returnRequiresLogin: Boolean
  supportEmail: String
  supportPhoneNumber: String
  supportUrl: String
  tosUrl: String
  supportHours: String
  returnInitUrl: String
  checkoutState: CheckoutStateType
}

type StoreDeal implements Node {
  """The ID of an object"""
  id: ID!
  dealId: ID!
  store: Store!
  storeId: ID!
  appliedCount: Int!
  appliedLastDiscount: Float
  appliedLastTs: Timestamp
  code: String!
  type: StoreDealType!
  state: StoreDealStateType!
  rank: Float!
  exclusive: Boolean!
  url: String
  affiliateLinkId: String
  description: String!
  restrictions: String
  notes: String!
  position: Int
  hiddenOnMobile: Boolean
  isProtectedDescription: Boolean!
  sources: [StoreDealSource!]!
  created: Timestamp!
  starts: Timestamp!
  expires: Timestamp
  remove: Timestamp
  updated: Timestamp!
  filtered: Boolean
  filterReason: FilterReason
  hidden: Boolean!
  hiddenReason: HiddenReason
  meta: StoreDealMeta
  tags: [String!]!
}

"""Fields available for creating a StoreDeal"""
input StoreDealCreateInput {
  dealId: ID
  appliedCount: Int
  appliedLastDiscount: Float
  appliedLastTs: Timestamp
  code: String!
  description: String!
  exclusive: Boolean
  expires: Timestamp
  notes: String!
  position: Int
  hiddenOnMobile: Boolean
  rank: Float
  hidden: Boolean
  remove: Timestamp
  restrictions: String
  starts: Timestamp
  state: StoreDealStateType!
  isProtectedDescription: Boolean
  type: StoreDealType!
  url: String
  affiliateLinkId: String
}

type StoreDealExclusion {
  id: ID!
  store: Store!
  storeId: ID!
  sourceType: StoreDealSourceType!
}

input StoreDealExclusionCreateInput {
  sourceType: StoreDealSourceType!
}

input StoreDealExclusionUpdateInput {
  sourceType: StoreDealSourceType!
}

type StoreDealMeta {
  couponClass: String
  percentOff: String
  dollarOff: String
  dollarMinimum: String
  noMinimum: Boolean
  freeShipping: Boolean
  freeDelivery: Boolean
  limitedTime: Boolean
  firstPurchase: Boolean
  entirePurchase: Boolean
  anyItem: Boolean
  sitewide: Boolean
  freeGift: Boolean
  bogo: Boolean
  onlineOnly: Boolean
  exclusions: Boolean
}

type StoreDealSource implements Node {
  """The ID of an object"""
  id: ID!
  deal: StoreDeal!
  sourceType: StoreDealSourceType!
  sourceUserId: ID
  sourceUser: User
  reportedCode: String
  created: Timestamp!
  updated: Timestamp!
}

input StoreDealSourceCreateInput {
  sourceType: StoreDealSourceType!
  sourceUserId: ID
  reportedCode: String
}

enum StoreDealSourceType {
  AF
  AFN
  AL
  APD
  AW
  CF
  CJ
  CN
  COUPONFOLLOW
  DEALSPLUS
  DK
  EBAY
  FLIPKART
  FMTC
  GR
  HOTELSTORM
  IA
  IB
  IR
  LC
  LS
  LSJ
  LT
  MANUAL
  OL
  OM
  OND
  PHG
  PJ
  RMN
  RMNM
  SAS
  SC
  SD
  SHIMPLY
  SNAPDEAL
  SZ
  TD
  TT
  USER
  VCOMM
  VORCU
  WG
  WX
  ZX
}

input StoreDealSourceUpdateInput {
  sourceUserId: ID
  updated: Timestamp
  reportedCode: String
}

enum StoreDealStateType {
  ACTIVE
  BANNED
  PINNED
}

enum StoreDealType {
  COUPON
  SALE
}

"""Fields available for updating a StoreDeal"""
input StoreDealUpdateInput {
  appliedCount: Int
  appliedLastDiscount: Float
  appliedLastTs: Timestamp
  isProtectedDescription: Boolean
  description: String
  exclusive: Boolean
  expires: Timestamp
  notes: String
  position: Int
  hiddenOnMobile: Boolean
  rank: Float
  remove: Timestamp
  hidden: Boolean
  restrictions: String
  starts: Timestamp
  state: StoreDealStateType
  url: String
  affiliateLinkId: String
}

type StoreExternalId implements Node {
  """The ID of an object"""
  id: ID!
  store: Store!
  storeId: ID!
  type: StoreExternalIdType!
  externalId: ID!
  created: Timestamp!
  updated: Timestamp!
}

"""Fields available for creation of a store external Id"""
input StoreExternalIdCreateInput {
  type: StoreExternalIdType!
  externalId: ID!
}

enum StoreExternalIdType {
  AF
  AFN
  AL
  APD
  AW
  CF
  CJ
  CN
  COUPONFOLLOW
  DEALSPLUS
  DK
  EBAY
  FLIPKART
  FMTC
  GR
  HOTELSTORM
  IA
  IB
  IR
  LC
  LS
  LSJ
  LT
  OL
  OM
  OND
  PHG
  PJ
  RMN
  RMNM
  SAS
  SC
  SD
  SHIMPLY
  SNAPDEAL
  SZ
  TD
  TT
  VCOMM
  VORCU
  WG
  WX
  ZX
}

"""Fields available for updating a store external Id"""
input StoreExternalIdUpdateInput {
  externalId: ID!
}

type StoreFollowRecommendations implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  stores: [Store!]!
}

input StoreFrontMetaInput {
  availability: Boolean
  brands: String
  categories: String
  limit: Int
  maxPrice: Int
  minPrice: Int
  offersOnly: Boolean
  hotDealsOnly: Boolean
  offset: Int
  colors: String
  sizes: String
  sort: String
  storeId: String
  tags: String
  userId: ID
}

"""
Store internationalization groups are stored in spanner stores.storeInternationalizationGroups,
  and describe a specific store's relationship to a parent store.
"""
type StoreInternationalizationGroup implements Node {
  """The ID of an object"""
  id: ID!

  """The store id of the child store"""
  storeId: ID!

  """Information about the parent store"""
  parentStore: BasicStoreInfo

  """New parent store id"""
  parentStoreId: String

  """Whether to borrow parent store's details"""
  useParentDetails: Boolean

  """Whether to borrow parent store's tips"""
  useParentTips: Boolean

  """Information about each child store"""
  children: [BasicStoreInfo!]
}

"""
Store links are stored in spanner stores.storeLinks, and represent urls that belong to a specific store.
"""
type StoreLink implements Node {
  """The ID of an object"""
  id: ID!

  """A unique db row identifier, for editing or deleting store links."""
  storeLinkId: String!

  """A URL's label. Limited to 64 characters."""
  storeLinkType: String!

  """A URL associated with a store. Limited to 128 characters."""
  storeLinkUrl: String!
}

input StoreNewsletterInput {
  emailType: String!
  users: [StoreNewsletterInputUsers!]!
}

input StoreNewsletterInputUsers {
  userEmail: String!
  userId: String!
}

type StoreOffer implements Node {
  """The ID of an object"""
  id: ID!
  campaignId: ID!
  offerId: String!
  storeId: String!
  value: Int!
  minimumOrderValue: Int!
  type: StoreOfferType!
  startDate: Timestamp!
  endDate: Timestamp
  storeName: String!
}

enum StoreOfferType {
  DIRECT
  ONBOARDING
}

type StorePartialURL implements Node {
  """The ID of an object"""
  id: ID!
  store: Store!
  storeId: ID!
  domain: String!
  partialURL: String!
  created: Timestamp!
  updated: Timestamp!
}

input StorePartialURLCreateInput {
  domain: String!
  partialURL: String!
}

input StorePartialURLUpdateInput {
  domain: String!
}

type StorePreference {
  score: Float!
  store: String!
}

input StorePreferenceInput {
  score: Float!
  store: String!
}

type StoreRecommendation implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
  storeRecommendationType: StoreRecommendationType!
  storeId: ID!
  store: Store!

  """TODO: will there be a v3 exclusives schema to use?"""
  bonusOffer: TempBonusOffer
}

"""
There are two types of store recommendation cards: Trending Store & Popular Store
"""
enum StoreRecommendationType {
  POPULAR_STORE
  TRENDING_STORE
}

type StoreRemoteModule implements Node {
  """The ID of an object"""
  id: ID!
  store: Store!
  storeId: ID!
  type: String!
  acornFile: String!
  fileState: StoreRemoteModuleFileStateType!
  options: String
  submitted: Timestamp!
}

input StoreRemoteModuleCreateInput {
  type: String!
  acornFile: String!
  fileState: StoreRemoteModuleFileStateType!
  options: String
  submitted: Timestamp
}

enum StoreRemoteModuleFileStateType {
  FAILED
  INACTIVE
  LIVE
}

input StoreRemoteModuleUpdateInput {
  acornFile: String
  fileState: StoreRemoteModuleFileStateType
  options: String
  submitted: Timestamp
}

input StoreRemoteModuleUpsertInput {
  acornFile: String!
  fileState: StoreRemoteModuleFileStateType!
  options: String
  submitted: Timestamp
}

"""Store sale information"""
type StoreSale implements Node {
  """The ID of an object"""
  id: ID!
  categoryContent: StoreSaleCategoryContent!
  productContent: StoreSaleProductContent!
  storeContent: StoreSaleStoreContent!
  storeId: ID!
  storeName: String!
}

type StoreSaleCategoryContent {
  category: String!
  categoryLevelKey: Int!
  indexItemCount: Int!
  percentOfItemsOverThreshold: Float!
  shown: Boolean!
}

type StoreSaleProductContent {
  dealScore: Int!
  discountAmount: Float!
  parentId: String!
  pdpViews: Int!
  popularity: Float!
  priority: Float!
  productId: String!
  productRank: Int!
  shown: Boolean!
  title: String!
  variantId: String!
}

type StoreSaleStoreContent {
  storeSale: Boolean!
  percentOfItemsWithDiscount: Float!
  shown: Boolean!
}

input StoresCashbackOfferCreate {
  active: Boolean!
  manual: Boolean!
  minPercent: Float
  maxPercent: Float
  isFlatFee: Boolean
  minFlatFee: Int
  maxFlatFee: Int
}

type StoresCashbackOfferResponse {
  active: Boolean!
  manual: Boolean!
  started: Timestamp!
  storeId: ID!
  minPercent: Float!
  maxPercent: Float!
  isFlatFee: Boolean!
  minFlatFee: Int!
  maxFlatFee: Int!
}

input StoresCashbackOfferUpdate {
  active: Boolean
  manual: Boolean
  minPercent: Float
  maxPercent: Float
  isFlatFee: Boolean
  minFlatFee: Int
  maxFlatFee: Int
}

type StoreScrape implements Node {
  """The ID of an object"""
  id: ID!
  store: Store!
  storeId: ID!
  scrapeType: String!
  lastScrape: Timestamp
  nextScrape: Timestamp
  period: Int
  relatedExternalId: StoreExternalId
}

input StoreScrapeCreateInput {
  scrapeType: String!
  lastScrape: Timestamp
  nextScrape: Timestamp
  period: Int
}

input StoreScrapeUpdateInput {
  lastScrape: Timestamp
  nextScrape: Timestamp
  period: Int
}

type StoreSearch {
  """Get stores by search query w/ meta fields returned"""
  stores: [Store!]!

  """Store search meta fields related to pagination"""
  meta: StoreSearchMeta!
}

type StoreSearchMeta {
  limit: Int
  offset: Int
  total: Int
}

type StoreSection implements Node {
  """The ID of an object"""
  id: ID!
  storeId: ID!
  sectionId: ID!
  sectionType: String!
  sectionHeader: String
  sectionBody: String
}

enum StoreSupportStageType {
  CANT_SUPPORT
  OBSTACLE
  PRE_DATABASE
  PRE_SUPPORT
  SUPPORTED_CHECKED
  SUPPORTED_NOT_CHECKED
}

type StoreTag implements Node {
  """The ID of an object"""
  id: ID!
  storeTag: String!
  storeTagType: String!
}

input StoreTagInput {
  storeTag: String!
  storeTagType: String!
}

enum StoreTagType {
  EXT_BUTTON_CLICK
  EXT_LINK
  OFFER_ACTIVATE
  WEB_LINK
}

"""Fields available for updating a Store"""
input StoreUpdateInput {
  active: Boolean
  affiliateRestrictions: String
  affiliateTagTypes: [StoreTagType!]
  affiliateURL: String
  avgSavings24h: Int
  avgSavings30d: Int
  avgSavingsChange: Int
  checked: Timestamp
  country: String
  created: Timestamp
  forceJsRedirect: Boolean
  hasCartSupport: Boolean
  hasIcon: Boolean
  hasImage: Boolean
  hasTrendingImage: Boolean
  indexShopPage: Boolean
  isGracefulFailure: Boolean
  label: String
  metadata: String
  name: String
  notesMonetization: String
  notesSupport: String
  notesWorker: String
  numSavings24h: Int
  numSavings30d: Int
  numSavingsChange: Int
  position: Int
  productRegex: [String]
  providerId: ID
  score: Int
  shoppers24h: Int
  shoppers30d: Int
  shoppersChange: Int
  supported: Boolean
  supportStage: StoreSupportStageType
  url: String
  returnInfo: String
  returnRequiresLogin: Boolean
  supportEmail: String
  supportPhoneNumber: String
  supportUrl: String
  tosUrl: String
  supportHours: String
  returnInitUrl: String
  checkoutState: CheckoutStateType
}

input Subscriptions {
  accountUpdates: Boolean
  cartNotifications: Boolean
  droplist: Boolean
  features: Boolean
  insiderDeals: Boolean
}

type Subtitle {
  type: SubtitleType!
  value: String!
}

enum SubtitleType {
  TEXT
  TIMESTAMP
}

input TagWelcomeInput {
  categories: [String!]
  checkUserActionEvent: Boolean
  customEmailType: String
  emailAddress: String!
  userId: String!
  visitorId: String
}

"""
TODO: this is just a placeholder, remove it when real schema is merged in
"""
type TempBonusOffer {
  bonusOfferId: ID!
  status: String!
  expires: Timestamp!
  goldValue: Int!
  minTrxValue: Float
}

"""Generic interface for specific templates to implement"""
interface Template {
  templateID: String!
  templateType: TemplateType!
}

"""enum of possible template types"""
enum TemplateType {
  NOTIFICATION_BASIC
  NotificationBasic @deprecated(reason: "Use 'NOTIFICATION_BASIC' instead.")
  RECOMMENDATION_BASIC
  RECOMMENDATION_COLUMN
  RecommendationBasic @deprecated(reason: "Use 'RECOMMENDATION_BASIC' instead.")
  RecommendationColumn @deprecated(reason: "Use 'RECOMMENDATION_COLUMN' instead.")
}

type TestSetting {
  testId: ID!
  testName: String!
  testStartDate: String!
  testEndDate: String!
  disabled: Boolean!
  groups(area: String): JSON
}

"""Time ranges for search"""
enum TimeRangeType {
  FORTY_EIGHT_HOURS
  NO_LIMIT
  ONE_HOUR
  SEVEN_DAYS
  SIX_HOURS
  TWENTY_FOUR_HOURS
}

"""Unix timestamp in milliseconds"""
scalar Timestamp

"""Transaction type"""
type Transaction implements Node {
  """The ID of an object"""
  id: ID!
  transactionId: ID!
  userId: ID
  type: TransactionType!
  state: TransactionState!
  value: Int!
  created: Timestamp!
  updated: Timestamp!
  locked: Timestamp
  lockedTime: Timestamp

  """either an affiliate or checkout store, depending on transaction type"""
  store: Store
  user: User

  """affiliate fields"""
  affiliateProviderId: AffiliateProviderIdType
  affiliateExternalId: String
  affiliateTrackId: String
  affiliateStoreId: ID
  affiliateSaleValueAtLocked: Int
  affiliateCommissionAtLocked: Int
  affiliateSaleValue: Int
  affiliateCommission: Int
  affiliateGivenPercent: Float
  affiliateExternalCreated: Timestamp
  affiliateExternalLocked: Timestamp
  affiliatePartials: String

  """checkout fields"""
  checkoutStoreId: ID
  checkoutSeen: Timestamp
  checkoutMinPercent: Float
  checkoutMaxPercent: Float
  checkoutSaleValue: Int

  """manual fields"""
  manualDescription: String
  manualComment: String

  """referral fields"""
  referredUser: User
  referralLinkedTransactionId: String
  referralReferredUserId: String

  """onboarding fields"""
  onboardingStep: OnboardingStepType

  """payout fields"""
  payoutGifts: [PayoutGift!]

  """offers fields"""
  offerClaimedOfferId: ID
  offerLinkedTransactionId: ID
  offerStoreId: ID
}

enum TransactionState {
  FOR_REVIEW
  LINKED
  LOCKED
  MISSING
  PENDING
  REJECTED
}

enum TransactionType {
  AFFILIATE
  CHECKOUT
  MANUAL
  OFFER
  OFFERS_LEGACY
  OFFER_PRODUCT
  OFFER_PRODUCT_EXT
  ONBOARDING
  PAYOUT
  REFERRAL
}

input TransactionUpdateInput {
  state: TransactionState
  value: Int
}

input TrustpilotReviewInput {
  users: [TrustpilotReviewInputUsers!]!
}

input TrustpilotReviewInputUsers {
  trustpilotUrl: String!
  userEmail: String!
  userId: String!
}

"""
Contains the response received from a proxied request to the Two Tap API
"""
type TwoTapApiResponse {
  """
  The response body. Keeping this schema-less since we are simply passing through the response.
  """
  twoTapResponse: Object!
}

"""
Contains the error information for a single store as reported by Two Tap
"""
type TwoTapOrderError {
  """First field for the composite key"""
  orderId: String!

  """Second field for the composite key"""
  twoTapOrderErrorId: String!

  """
  Comes from the root level of the Two Tap Purchase object with the same name
  """
  message: String

  """
  Comes from the root level of the Two Tap Purchase object with the same name
  """
  description: String

  """
  Comes from the "site" object in the Two Tap Purchase object with the same name
  """
  status: String

  """
  Comes from the "site" object in the Two Tap Purchase object, but camelCased (original is "status_reason")
  """
  statusReason: String

  """
  Comes from the "site" object in the Two Tap Purchase object with the same name
  """
  statusMessages: [String]

  """Timestamp of when this user saw this error"""
  seenAt: Timestamp

  """Timestamp of when this user dismissed the error notification"""
  dismissedAt: Timestamp
}

"""
Fields available for updating the twoTapOrderError property of a CartOrder
"""
input TwoTapOrderErrorUpdateInput {
  """ID of the honey order"""
  orderId: ID

  """Error description"""
  description: String

  """Timestamp of when this user saw this error"""
  seenAt: Timestamp

  """Timestamp of when this user dismissed the error notification"""
  dismissedAt: Timestamp

  """Timestamp of when error occured"""
  erroredAt: Timestamp

  """message field from TwoTap /purchase/status response"""
  message: String

  """status field from TwoTap /purchase/status response"""
  status: String

  """status_messages field from TwoTap /purchase/status response"""
  statusMessages: String

  """status_reason field from TwoTap /purchase/status response"""
  statusReason: String

  """Id of Honey user"""
  userId: ID
}

"""Contains information about a purchase made with Two Tap"""
type TwoTapPurchase {
  """Id of user who owns this Two Tap purchase"""
  userId: String!

  """Purchase id"""
  purchaseId: String!
}

input UpdateSenderDomainInput {
  """Store ID"""
  storeId: String!

  """Email domain"""
  domain: String!

  """Whether domain is currently active"""
  isActive: Boolean!
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

"""URL following correct format"""
scalar URL

type User implements Node {
  """The ID of an object"""
  id: ID!
  userId: ID!
  email: String!
  maskedEmail: String!
  referralToken: String!
  roleGroups: [String!]!
  facebookId: String
  googleId: String
  paypalId: String
  created: Timestamp!
  infoVersion: String!
  infoTtl: Int!
  firstName: String
  lastName: String
  name: String
  bio: String
  countryCode: String
  countryName: String
  hasImage: Binary
  imageUrl: String
  optimusShowBest: Binary
  reviewed: String
  shareData: Binary
  offers: Binary
  optimus: Binary
  ugcAttribution: Binary
  allowManualCodes: String
  dropListSync1: Binary
  honeyPay: Binary
  honeyWallet: Binary
  tipsEnabled: Binary
  smartDroplistOptedIn: Binary
  dropListEmail: Binary @deprecated(reason: "Legacy migration field. (see CS-852)")
  emailSubscribe_droplist: Boolean @deprecated(reason: "Use 'emailSubscribeDroplist' instead. (see CS-388)")
  emailSubscribe_features: Boolean @deprecated(reason: "Use 'emailSubscribeFeatures' instead. (see CS-388)")
  emailSubscribe_insiderDeals: Boolean @deprecated(reason: "Use 'emailSubscribeInsiderDeals' instead. (see CS-388)")
  emailSubscribe_accountUpdates: Boolean @deprecated(reason: "Use 'emailSubscribeAccountUpdates' instead. (see CS-388)")
  emailSubscribe_cartNotifications: Boolean @deprecated(reason: "Use 'emailSubscribeCartNotifications' instead. (see CS-388)")
  emailSubscribeDroplist: Boolean
  emailSubscribeFeatures: Boolean
  emailSubscribeInsiderDeals: Boolean
  emailSubscribeAccountUpdates: Boolean
  emailSubscribeCartNotifications: Boolean
  pushNotification_droplist: Boolean @deprecated(reason: "Use pushNotificationDroplist")
  pushNotification_honeyGold: Boolean @deprecated(reason: "No replacement")
  pushNotification_specialGoldOffers: Boolean @deprecated(reason: "Use pushNotificationOffers")
  pushNotification_featureAnnouncements: Boolean @deprecated(reason: "No replacement")
  pushNotification_doNotDisturb: Boolean @deprecated(reason: "No replacement")
  pushNotificationDoNotDisturb: Boolean @deprecated(reason: "No replacement")

  """
  Keeps track of whether or not the user has opted in for cart notifications
  """
  pushNotificationCart: Boolean

  """
  Keeps track of whether or not the user has opted in for checkout notifications
  """
  pushNotificationCheckout: Boolean

  """
  Keeps track of whether or not the user has opted in for droplist notifications
  """
  pushNotificationDroplist: Boolean

  """
  Keeps track of whether or not the user has opted in for offers notifications
  """
  pushNotificationOffers: Boolean

  """
  Keeps track of whether or not the user has opted in for stores notifications
  """
  pushNotificationStores: Boolean
  ambassador: Boolean
  appHeartbeat: Timestamp
  paypalEmail: String
  recentSearches: String
  points: UsersPoints

  """This should only be requested by internal sources"""
  profile(types: [String!]!): [UserProfileEntry]!
  priceChangeModal: Binary
  droplistTooltips: String
  onboarding: Object
  carouselExpires: Timestamp

  """
  Keeps track of the last time offers push notification was last sent to a User
  """
  lastOffersPushNotification: Timestamp

  """
  Keeps track of the last time droplist push notification was last sent to a User
  """
  lastDroplistPushNotification: Timestamp

  """
  Keeps track of the last time order push notification was last sent to a User
  """
  lastOrderPushNotification: Timestamp
  fullOffers: [FullOffer]!
  cartStoreAccount: CartStoreAccount
  cart(query: CartQuery!): Cart!
  creditCard(creditcardId: String!): CreditCard!
  creditCards: [CreditCard!]!
  shippingAddress(shippingAddressId: String!): ShippingAddress!
  shippingAddresses: [ShippingAddress!]!
  defaultCreditCard: CreditCard
  defaultShippingAddress: ShippingAddress
  honeyOrder(query: HoneyOrderQuery): HoneyOrder
  honeyOrders(query: HoneyOrdersQuery!): [HoneyOrder!]!
  orders(query: OrderQuery!): [CartOrder!]!
  registeredFrom: String

  """A list of platforms a user has logged in with"""
  userPlatforms: [String!]!

  """If a user has an active honey pay loan"""
  activeBorrower: Boolean!

  """If a user has been flagged by security"""
  blacklisted: Boolean!

  """User store or tag follows"""
  userFollow(type: UserFollowType!): UserFollow

  """If a user has any referrals"""
  hasReferrals: Boolean!

  """If a user has added any products to their droplist"""
  hasDroplist: Boolean!

  """Timestamp of the user's last login"""
  lastLogin: Timestamp
}

type UserAmbassadorState {
  user: User!
  userId: ID!
  state: AmbassadorApplicationState!
  created: Timestamp!
  updated: Timestamp!
}

enum UserAuthMethod {
  EMAIL
  FACEBOOK
  GOOGLE
  GOOGLE_HONEY
  PAYPAL
}

type UserDeletion implements Node {
  """The ID of an object"""
  id: ID!
  timestamp: Timestamp
}

type UserFollow implements Node {
  """The ID of an object"""
  id: ID!
  userId: ID!
  created: Timestamp!
  updated: Timestamp!
  type: String!
  values: [String!]
}

enum UserFollowAction {
  FOLLOW
  UNFOLLOW
}

input UserFollowInput {
  action: UserFollowAction = FOLLOW
  type: UserFollowType!
  values: [String!]!
}

enum UserFollowType {
  STORE
  TAG
}

type UserGeneratedCoupon {
  id: ID!
  store: Store!
  storeId: ID!
  code: String!
  description: String!
  sourceUser: User!
  appliedCount: Int!
  appliedLastTs: Timestamp
  successCount: Int!
  successUsers: [User]
  firstReported: Timestamp!
  lastReported: Timestamp!
  expires: Timestamp
  sourceUserId: ID
}

input UserGeneratedCouponInputType {
  code: String!
  description: String
  appliedCount: Int
  appliedLastTs: Timestamp
  sourceUserId: ID
  successCount: Int
  successUserIds: [String]
  firstReported: Timestamp
  lastReported: Timestamp
  expires: Timestamp
}

input UserGeneratedCouponUpdateType {
  description: String
  appliedCount: Int
  appliedLastTs: Timestamp
  sourceUserId: ID
  successCount: Int
  successUserIds: [String]
  firstReported: Timestamp
  lastReported: Timestamp
  expires: Timestamp
}

input UserInfoInput {
  firstName: String
  lastName: String
  bio: String
  hasImage: Binary
  countryCode: String
  countryName: String
  optimusShowBest: Binary
  reviewed: String
  shareData: Binary
  offers: Binary
  optimus: Binary
  ugcAttribution: Binary
  allowManualCodes: String
  dropListSync1: Binary
  honeyPay: Binary
  honeyWallet: Binary
  tipsEnabled: Binary
  smartDroplistOptedIn: Binary
  dropListEmail: Binary
  emailSubscribe_accountUpdates: Boolean
  emailSubscribe_cartNotifications: Boolean
  emailSubscribe_droplist: Boolean
  emailSubscribe_features: Boolean
  emailSubscribe_insiderDeals: Boolean
  pushNotificationCart: Boolean
  pushNotificationCheckout: Boolean
  pushNotificationDroplist: Boolean
  pushNotificationOffers: Boolean
  pushNotificationStores: Boolean
  appHeartbeat: Timestamp
  recentSearches: String
  priceChangeModal: Binary
  carouselExpires: Timestamp
  lastOffersPushNotification: Timestamp
  lastDroplistPushNotification: Timestamp
  lastOrderPushNotification: Timestamp
  lastCheckoutPushNotification: Timestamp
  lastCartPushNotification: Timestamp
  paypalEmail: String
}

type UserInReview {
  user: User!
  userId: ID!
  ruleSetId: String!
  created: Timestamp
}

type UserNote {
  author: User!
  created: DateTime!
  note: String!
  userId: ID!
}

type UserProfileEntry {
  type: String!
  value: JSON!
  updated: Timestamp!
}

type UsersPoints implements Node {
  """The ID of an object"""
  id: ID!
  userId: ID!
  pointsPendingDeposit: Int!
  pointsPendingWithdrawal: Int!
  pointsAvailable: Int!
  pointsRedeemed: Int!
}

type UserTestSetting {
  testName: String!
  testStartDate: String!
  testEndDate: String!
  groupId: ID!
  groupName: String!
}

"""
This type is temporary for the users migration, should be deprecated ASAP
"""
type UserTokenPair {
  refreshToken: String!
  accessToken: String!
}

type UserWithVersionCheck {
  upToDate: Boolean!
  user: User
}

input WalletAuthInput {
  device: String!
  email: String!
  name: String!
  platform: String!
  subject: String
  url: String!
}

"""Wallet email card -- still getting spec'd out"""
type WalletEmailCard implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!

  """this probably will get made into some sort of Order type"""
  orderId: String!

  """get `name`"""
  store: Store!
}

type WalletEmailRegex {
  category: CategoryTypeEnum!
  flags: String!
  listType: ListTypeEnum!
  pattern: String!
  regexId: String
  storeId: String!
}

input WalletEmailRegexInsertInput {
  category: CategoryTypeEnum!
  flags: String!
  listType: ListTypeEnum!
  pattern: String!
  storeId: String!
}

type WalletEmailRegexMask {
  category: CategoryTypeEnum!
  flags: String!
  listType: ListTypeEnum!
  pattern: String!
  maskId: String!
  regexId: String
  storeId: String!
}

input WalletEmailRegexUpdateInput {
  category: CategoryTypeEnum
  flags: String
  listType: ListTypeEnum
  pattern: String
  storeId: String
}

type Welcome implements Card {
  id: String!
  ts: Timestamp!
  cardType: String!
  trackingData: Object!
}

input WelcomeReminderInput {
  categories: [String!]
  customEmailType: String
  userEmail: String!
  userId: String
  visitorId: String
}

type WhitelistedStore {
  storeId: String!
  storeName: String!
}
